<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="de"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ChangesFileSaxHandler.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">ODFDOM</a> &gt; <a href="index.source.html" class="el_package">org.odftoolkit.odfdom.changes</a> &gt; <span class="el_source">ChangesFileSaxHandler.java</span></div><h1>ChangesFileSaxHandler.java</h1><pre class="source lang-java linenums">/**
 * **********************************************************************
 *
 * &lt;p&gt;DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER
 *
 * &lt;p&gt;Use is subject to license terms.
 *
 * &lt;p&gt;Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file
 * except in compliance with the License. You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0.
 *
 * &lt;p&gt;Unless required by applicable law or agreed to in writing, software distributed under the
 * License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied.
 *
 * &lt;p&gt;See the License for the specific language governing permissions and limitations under the
 * License.
 *
 * &lt;p&gt;**********************************************************************
 */
package org.odftoolkit.odfdom.changes;

import static org.odftoolkit.odfdom.changes.OperationConstants.CONFIG_MAX_TABLE_CELLS;
import static org.odftoolkit.odfdom.changes.OperationConstants.CONFIG_MAX_TABLE_COLUMNS;
import static org.odftoolkit.odfdom.changes.OperationConstants.CONFIG_MAX_TABLE_ROWS;
import static org.odftoolkit.odfdom.changes.OperationConstants.OPK_STYLE_ID;
import static org.odftoolkit.odfdom.changes.PageArea.FOOTER_DEFAULT;
import static org.odftoolkit.odfdom.changes.PageArea.FOOTER_EVEN;
import static org.odftoolkit.odfdom.changes.PageArea.FOOTER_FIRST;
import static org.odftoolkit.odfdom.changes.PageArea.HEADER_DEFAULT;
import static org.odftoolkit.odfdom.changes.PageArea.HEADER_EVEN;
import static org.odftoolkit.odfdom.changes.PageArea.HEADER_FIRST;

import java.io.IOException;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.ListIterator;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.Stack;
import java.util.logging.Level;
import java.util.logging.Logger;
import org.json.JSONException;
import org.json.JSONObject;
import org.odftoolkit.odfdom.doc.OdfDocument;
import org.odftoolkit.odfdom.dom.OdfContentDom;
import org.odftoolkit.odfdom.dom.OdfDocumentNamespace;
import org.odftoolkit.odfdom.dom.OdfMetaDom;
import org.odftoolkit.odfdom.dom.OdfSchemaConstraint;
import org.odftoolkit.odfdom.dom.OdfSchemaDocument;
import org.odftoolkit.odfdom.dom.OdfSettingsDom;
import org.odftoolkit.odfdom.dom.OdfStylesDom;
import org.odftoolkit.odfdom.dom.element.OdfStylableElement;
import org.odftoolkit.odfdom.dom.element.OdfStyleableShapeElement;
import org.odftoolkit.odfdom.dom.element.draw.DrawConnectorElement;
import org.odftoolkit.odfdom.dom.element.draw.DrawFrameElement;
import org.odftoolkit.odfdom.dom.element.draw.DrawGElement;
import org.odftoolkit.odfdom.dom.element.draw.DrawImageElement;
import org.odftoolkit.odfdom.dom.element.draw.DrawLineElement;
import org.odftoolkit.odfdom.dom.element.draw.DrawMeasureElement;
import org.odftoolkit.odfdom.dom.element.draw.DrawShapeElementBase;
import org.odftoolkit.odfdom.dom.element.draw.DrawTextBoxElement;
import org.odftoolkit.odfdom.dom.element.office.OfficeAnnotationElement;
import org.odftoolkit.odfdom.dom.element.office.OfficeAnnotationEndElement;
import org.odftoolkit.odfdom.dom.element.style.StyleFontFaceElement;
import org.odftoolkit.odfdom.dom.element.style.StyleFooterStyleElement;
import org.odftoolkit.odfdom.dom.element.style.StyleHeaderFooterPropertiesElement;
import org.odftoolkit.odfdom.dom.element.style.StyleHeaderStyleElement;
import org.odftoolkit.odfdom.dom.element.style.StyleMasterPageElement;
import org.odftoolkit.odfdom.dom.element.style.StyleStyleElement;
import org.odftoolkit.odfdom.dom.element.svg.SvgDescElement;
import org.odftoolkit.odfdom.dom.element.table.TableCoveredTableCellElement;
import org.odftoolkit.odfdom.dom.element.table.TableTableCellElement;
import org.odftoolkit.odfdom.dom.element.table.TableTableColumnElement;
import org.odftoolkit.odfdom.dom.element.table.TableTableElement;
import org.odftoolkit.odfdom.dom.element.table.TableTableRowElement;
import org.odftoolkit.odfdom.dom.element.text.TextAElement;
import org.odftoolkit.odfdom.dom.element.text.TextHElement;
import org.odftoolkit.odfdom.dom.element.text.TextLineBreakElement;
import org.odftoolkit.odfdom.dom.element.text.TextListElement;
import org.odftoolkit.odfdom.dom.element.text.TextListHeaderElement;
import org.odftoolkit.odfdom.dom.element.text.TextListItemElement;
import org.odftoolkit.odfdom.dom.element.text.TextListStyleElement;
import org.odftoolkit.odfdom.dom.element.text.TextNoteCitationElement;
import org.odftoolkit.odfdom.dom.element.text.TextPElement;
import org.odftoolkit.odfdom.dom.element.text.TextParagraphElementBase;
import org.odftoolkit.odfdom.dom.element.text.TextSElement;
import org.odftoolkit.odfdom.dom.element.text.TextSpanElement;
import org.odftoolkit.odfdom.dom.element.text.TextTabElement;
import org.odftoolkit.odfdom.dom.element.text.TextUserFieldDeclElement;
import org.odftoolkit.odfdom.dom.style.OdfStyleFamily;
import org.odftoolkit.odfdom.incubator.doc.office.OdfOfficeAutomaticStyles;
import org.odftoolkit.odfdom.incubator.doc.office.OdfOfficeStyles;
import org.odftoolkit.odfdom.incubator.doc.style.OdfStyle;
import org.odftoolkit.odfdom.incubator.doc.style.OdfStylePageLayout;
import org.odftoolkit.odfdom.incubator.doc.text.OdfTextListStyle;
import org.odftoolkit.odfdom.pkg.OdfAttribute;
import org.odftoolkit.odfdom.pkg.OdfElement;
import org.odftoolkit.odfdom.pkg.OdfFileDom;
import org.odftoolkit.odfdom.pkg.OdfName;
import org.odftoolkit.odfdom.pkg.OdfNamespace;
import org.odftoolkit.odfdom.pkg.OdfValidationException;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.w3c.dom.Text;
import org.xml.sax.Attributes;
import org.xml.sax.ErrorHandler;
import org.xml.sax.InputSource;
import org.xml.sax.SAXException;

/** @author svante.schubertATgmail.com */
public class ChangesFileSaxHandler extends org.odftoolkit.odfdom.pkg.OdfFileSaxHandler {

<span class="fc" id="L121">  private static final Logger LOG = Logger.getLogger(ChangesFileSaxHandler.class.getName());</span>
  private static final String ROW_SPAN = &quot;rowSpan&quot;;
  // ToDo: Fix API with its 'ugly' property name
  private static final String COLUMN_SPAN = &quot;gridSpan&quot;;
  // ODF value types used for cell content
  private static final String LIBRE_OFFICE_MS_INTEROP_NAMESPACE =
      &quot;urn:openoffice:names:experimental:ooo-ms-interop:xmlns:field:1.0&quot;;
  private static final String LIBRE_OFFICE_MS_INTEROP_TYPE_CHECKBOX =
      &quot;vnd.oasis.opendocument.field.FORMCHECKBOX&quot;;
  private static final String LIBRE_OFFICE_MS_INTEROP_CHECKBOX_UNICODE = &quot;\u25A1&quot;;
<span class="fc" id="L131">  private static final Integer ONE = 1;</span>

<span class="fc" id="L133">  public static String COMMENT_PREFIX = &quot;cmt&quot;;</span>
  // the empty XML file to which nodes will be added
  private OdfFileDom mFileDom;
  private JsonOperationProducer mJsonOperationProducer;
<span class="fc" id="L137">  private Map&lt;String, TextListStyleElement&gt; mAutoListStyles = null;</span>
<span class="fc" id="L138">  private Map&lt;String, TextUserFieldDeclElement&gt; mUserFieldDecls = null;</span>
  /**
   * Represents a stack of TextSpanElement. The text span will be added during startElement(..) with
   * the start address of text span And during endElement(..) the correct span will be returned and
   * the end address can be provided as well.
   */
  private final ArrayDeque&lt;TextSelection&gt; mTextSelectionStack;

<span class="fc" id="L146">  private final StringBuilder mCharsForElement = new StringBuilder();</span>
  // Text for operations will be collected separately to allow to push not at every new delimiter
  // (e.g. span).
  // In addition will be &lt;text:s/&gt; in the output string exchange to spaces
<span class="fc" id="L150">  private final StringBuilder mCharsForOperation = new StringBuilder();</span>
  // Gatheres the start text position for operations
<span class="fc" id="L152">  private boolean mIsCharsBeginning = true;</span>
<span class="fc" id="L153">  List&lt;Integer&gt; mCharsStartPosition = null;</span>
<span class="fc" id="L154">  private int mComponentDepth = -1; // as component depth starts with zero</span>
  // the actual component. Linking each other building the tree view of the document
  private Component mCurrentComponent;
  // the position of the component, being updated for the operations being generated
<span class="fc" id="L158">  private final LinkedList&lt;Integer&gt; mLastComponentPositions = new LinkedList&lt;Integer&gt;();</span>
  /** DOM is created by default, but is in general not needed */
<span class="fc" id="L160">  private final boolean domCreationEnabled = true;</span>
  //    private final ArrayDeque&lt;ShapeProperties&gt; mShapePropertiesStack;
  // *** TABLE PROPERTIES ***
  // ToDo: Move this table member variables to a special Table related parser/evaluator (Strategy
  // Pattern?)
  // name of the table or spreadsheet
  private String mTableName;
  private TableTableElement mTableElement;
  private List&lt;TableTableColumnElement&gt; mColumns;
  // The relative widths of the columns of a table
  private List&lt;Integer&gt; mColumnRelWidths;

  private int mColumnCount;
  // Required as the component table/draw can only be delayed created,
  // After the first child has been parsed.. And should ONLY ONCE created!
<span class="fc" id="L175">  private boolean isTableNew = false;</span>
<span class="fc" id="L176">  Map&lt;String, Object&gt; mTableHardFormatting = null;</span>
  // *** LIST Properties ***
  // @text:start-value is provided to the first paragraph only
<span class="fc" id="L179">  private int mListStartValue = -1;</span>
  private final ArrayDeque&lt;ParagraphListProperties&gt; mListStyleStack;
  // used to track in a text:h/text:p if currently whitespace is being deleted/trimmed
  private final ArrayDeque&lt;WhitespaceStatus&gt; mWhitespaceStatusStack;
  /**
   * Quick cache to get the correct linked list. Key is the xml:id of the first list. The sequence
   * of all continued lists and usability functions are provided by ContinuedList
   */
<span class="fc" id="L187">  private final Map&lt;String, ContinuedList&gt; mLinkedLists = new HashMap&lt;String, ContinuedList&gt;();</span>
  // *** FOR BLOCKING OPERATIONS
  // the number of elements above the current element during parsing.
  // Required to find out if the correct blocking element for the UI was found
<span class="fc" id="L191">  int mElementDepth = 0;</span>
  // The depth of the element responsible of blocking further operations
<span class="fc" id="L193">  int mBlockingElementDepth = 0;</span>
<span class="fc" id="L194">  boolean mNoOperationsAllowed = false;</span>
  // All following blocking modes have different behavior
<span class="fc" id="L196">  boolean mIsBlockingFrame = false; // itself and children are allowed</span>
<span class="fc" id="L197">  boolean mIsIgnoredElement = false; // not even itself allowed</span>
<span class="fc" id="L198">  boolean mIsBlockingShape = false; // itself allowed</span>
  // RunTimeConfiguration given by the caller of the ODF Adapter
  private int mMaxAllowedColumnCount;
  private int mMaxAllowedRowCount;
  private int mMaxAllowedCellCount;

  /**
   * LO/AOO/Calligra are applying to Hyperlinks the &quot;Internet_20_link&quot; style, without writing out
   * the dependency into XML. Therefore whenever a Hyperlink exists without character style
   * properties, the reference will be set.
   */
  private static final String HYERLINK_DEFAULT_STYLE = &quot;Internet_20_link&quot;;

<span class="fc" id="L211">  private boolean mHasHyperlinkTemplateStyle = false;</span>

  /** Properties for the HEADER_DEFAULT and FOOTER_DEFAULT page area. Defining the page layout */
<span class="fc" id="L214">  private String mMasterPageStyleName = null;</span>

<span class="fc" id="L216">  private String mPageLayoutName = null;</span>
  /** ODF attribute on pageLayout */
<span class="fc" id="L218">  private String mPageStyleUsage = null;</span>
  /** indication of being a first page */
<span class="fc" id="L220">  private boolean mHasNextMasterPage = false;</span>

<span class="fc" id="L222">  private JSONObject headerAttrs = null;</span>
<span class="fc" id="L223">  private JSONObject footerAttrs = null;</span>

  /**
   * In the beginning it is only the styleId of the masterPage plus &quot;HeaderDefault&quot; or
   * &quot;FooterDefault&quot;
   */
<span class="fc" id="L229">  private String mContextName = null;</span>

  public static final String CONTEXT_DELIMITER = &quot;_&quot;;
<span class="fc" id="L232">  PageArea mPageArea = null;</span>

  /**
   * &quot;footer_default_&quot; &quot;footer_even_&quot; &quot;footer_first_&quot; &quot;header_default_&quot; &quot;header_even_&quot;
   * &quot;header_first_&quot;
   */
  /** The document might be of different types */
<span class="fc" id="L239">  String mMediaType = null;</span>

  /**
   * Required as the order of linked-list is important! All xml:ids of a connected/linked lists are
   * put into a single list. This collection is used to get the correct reference to the xml:id of
   * the preceding list and have to be updated, when linked lists are created, deleted or moved.
   * Only the text:continue-list of a new list will be evaluated
   */
  class ContinuedList {

    private String mListId;
<span class="fc" id="L250">    private List&lt;String&gt; mSortedIds = null;</span>

<span class="fc" id="L252">    public ContinuedList(String precedingListId, String currentListId) {</span>
<span class="pc bpc" id="L253" title="3 of 4 branches missed.">      if (precedingListId != null &amp;&amp; !precedingListId.isEmpty()) {</span>
<span class="nc" id="L254">        mListId = precedingListId;</span>
      } else {
<span class="pc bpc" id="L256" title="2 of 4 branches missed.">        if (currentListId != null &amp;&amp; !currentListId.isEmpty()) {</span>
<span class="fc" id="L257">          mListId = currentListId;</span>
        }
      }
<span class="fc" id="L260">      mSortedIds = new LinkedList&lt;String&gt;();</span>
<span class="fc" id="L261">    }</span>

    public void add(String listId) {
<span class="fc" id="L264">      mSortedIds.add(listId);</span>
<span class="fc" id="L265">    }</span>

    public List&lt;String&gt; getListIds() {
<span class="nc" id="L268">      return mSortedIds;</span>
    }

    public String getListId() {
<span class="fc" id="L272">      return mListId;</span>
    }
  }

  /**
   * Checks if the preceding list is already part of a continued list, otherwise creates a new
   * continued list and adds both ids to it
   */
  ContinuedList newContinuedList(String precedingListId, String currentListId) {
    ContinuedList continuedList;
<span class="pc bpc" id="L282" title="1 of 2 branches missed.">    if (!mLinkedLists.containsKey(precedingListId)) {</span>
<span class="nc" id="L283">      continuedList = new ContinuedList(precedingListId, currentListId);</span>
<span class="nc" id="L284">      continuedList.add(precedingListId);</span>
<span class="nc" id="L285">      mLinkedLists.put(precedingListId, continuedList);</span>
    } else {
<span class="fc" id="L287">      continuedList = mLinkedLists.get(precedingListId);</span>
    }
<span class="pc bpc" id="L289" title="2 of 4 branches missed.">    if (currentListId != null &amp;&amp; !currentListId.isEmpty()) {</span>
<span class="fc" id="L290">      continuedList.add(currentListId);</span>
<span class="fc" id="L291">      mLinkedLists.put(currentListId, continuedList);</span>
    }
<span class="fc" id="L293">    return continuedList;</span>
  }

  /**
   * Checks if the preceding list is already part of a continued list, otherwise creates a new
   * continued list and adds both id to it
   */
  ContinuedList newContinuedList(String currentListId) {
<span class="fc" id="L301">    ContinuedList continuedList = null;</span>
<span class="pc bpc" id="L302" title="2 of 4 branches missed.">    if (currentListId != null &amp;&amp; !currentListId.isEmpty()) {</span>
<span class="fc bfc" id="L303" title="All 2 branches covered.">      if (!mLinkedLists.containsKey(currentListId)) {</span>
<span class="fc" id="L304">        continuedList = new ContinuedList(null, currentListId);</span>
<span class="fc" id="L305">        mLinkedLists.put(currentListId, continuedList);</span>
      } else {
<span class="fc" id="L307">        continuedList = mLinkedLists.get(currentListId);</span>
      }
    }
<span class="fc" id="L310">    return continuedList;</span>
  }

  /**
   * The whitespace status of a text container (ie. paragraph or heading). Required for whitespace
   * handling
   */
  class WhitespaceStatus {

<span class="fc" id="L319">    WhitespaceStatus(boolean isParagraphIgnored, int depth) {</span>
<span class="fc" id="L320">      mDepth = depth;</span>
      //            mIsParagraphIgnored = isParagraphIgnored;
<span class="fc" id="L322">    }</span>

<span class="fc" id="L324">    int mDepth = -1;</span>

    public int getParagraphDepth() {
<span class="nc" id="L327">      return mDepth;</span>
    }

<span class="fc" id="L330">    boolean mOnlyWhiteSpaceSoFar = true;</span>
<span class="fc" id="L331">    int mFirstSpaceCharPosition = -1;</span>

    public boolean hasOnlyWhiteSpace() {
<span class="fc" id="L334">      return mOnlyWhiteSpaceSoFar;</span>
    }

    public void setOnlyWhiteSpace(boolean onlyWhiteSpace) {
<span class="fc" id="L338">      mOnlyWhiteSpaceSoFar = onlyWhiteSpace;</span>
<span class="fc" id="L339">    }</span>

    /** During parsing the first character of space siblings. -1 if there is no space sibling */
    public int getFirstSpaceCharPosition() {
<span class="nc" id="L343">      return mFirstSpaceCharPosition;</span>
    }

    /** During parsing the first character of space siblings. -1 if there is no space sibling */
    public void setFirstSpaceCharPosition(int currentSpaceCharPosition) {
<span class="fc" id="L348">      mFirstSpaceCharPosition = currentSpaceCharPosition;</span>
<span class="fc" id="L349">    }</span>

    /** @return true if the previous character was a white space character */
    public boolean hasSpaceBefore() {
<span class="fc bfc" id="L353" title="All 2 branches covered.">      return mFirstSpaceCharPosition &gt; -1;</span>
    }
  }

<span class="fc" id="L357">  OdfSchemaDocument mSchemaDoc = null;</span>

  // Candidate Component Mode
  // Some components consist of multiple XML elements.
  // Even some ODF components start with the same
  // 2DO - DRAGON BOOK - Parser Look-ahead does not work with SAX? ;)
  // private boolean isCandidateComponentMode = true;
  public ChangesFileSaxHandler(Node rootNode) throws SAXException {
<span class="fc" id="L365">    super(rootNode);</span>
    // Initialize starting DOM node
<span class="pc bpc" id="L367" title="1 of 2 branches missed.">    if (rootNode instanceof OdfFileDom) {</span>
<span class="fc" id="L368">      mFileDom = (OdfFileDom) rootNode;</span>
    } else {
<span class="nc" id="L370">      mFileDom = (OdfFileDom) rootNode.getOwnerDocument();</span>
    }
<span class="fc" id="L372">    mCurrentNode = rootNode;</span>

    // *** COMPONENT HANDLING ***
    // Initialize starting Component
    // Make the root of component tree (to be created) accessible via the ODF schema document
<span class="fc" id="L377">    mSchemaDoc = (OdfSchemaDocument) mFileDom.getDocument();</span>
<span class="pc bpc" id="L378" title="1 of 2 branches missed.">    if (mSchemaDoc != null) {</span>
      // cash the unfinished DOM otherwise, styles.xml might be tried to be parsed again
<span class="fc bfc" id="L380" title="All 2 branches covered.">      if (mFileDom instanceof OdfContentDom) {</span>
<span class="fc" id="L381">        mSchemaDoc.setContentDom((OdfContentDom) mFileDom);</span>
<span class="pc bpc" id="L382" title="1 of 2 branches missed.">      } else if (mFileDom instanceof OdfStylesDom) {</span>
<span class="fc" id="L383">        mSchemaDoc.setStylesDom((OdfStylesDom) mFileDom);</span>
<span class="nc bnc" id="L384" title="All 2 branches missed.">      } else if (mFileDom instanceof OdfMetaDom) {</span>
<span class="nc" id="L385">        mSchemaDoc.setMetaDom((OdfMetaDom) mFileDom);</span>
<span class="nc bnc" id="L386" title="All 2 branches missed.">      } else if (mFileDom instanceof OdfSettingsDom) {</span>
<span class="nc" id="L387">        mSchemaDoc.setSettingsDom((OdfSettingsDom) mFileDom);</span>
      }
    }

    // The current component is the root component
<span class="fc" id="L392">    mCurrentComponent = null;</span>

    // Getting Configuration
<span class="fc" id="L395">    Map&lt;String, Object&gt; configuration = mSchemaDoc.getPackage().getRunTimeConfiguration();</span>
<span class="fc" id="L396">    mMaxAllowedColumnCount = OperationConstants.MAX_SUPPORTED_COLUMNS_NUMBER;</span>
<span class="fc" id="L397">    mMaxAllowedRowCount = OperationConstants.MAX_SUPPORTED_ROWS_NUMBER;</span>
<span class="fc" id="L398">    mMaxAllowedCellCount = OperationConstants.MAX_SUPPORTED_CELLS_NUMBER;</span>
<span class="fc" id="L399">    mMediaType = mSchemaDoc.getMediaTypeString();</span>

<span class="fc bfc" id="L401" title="All 2 branches covered.">    if (configuration != null) {</span>
<span class="fc bfc" id="L402" title="All 2 branches covered.">      if (configuration.containsKey(CONFIG_MAX_TABLE_COLUMNS)) {</span>
<span class="fc" id="L403">        mMaxAllowedColumnCount = (Integer) configuration.get(CONFIG_MAX_TABLE_COLUMNS);</span>
      }
<span class="fc bfc" id="L405" title="All 2 branches covered.">      if (configuration.containsKey(CONFIG_MAX_TABLE_ROWS)) {</span>
<span class="fc" id="L406">        mMaxAllowedRowCount = (Integer) configuration.get(CONFIG_MAX_TABLE_ROWS);</span>
      }
<span class="fc bfc" id="L408" title="All 2 branches covered.">      if (configuration.containsKey(CONFIG_MAX_TABLE_CELLS)) {</span>
<span class="fc" id="L409">        mMaxAllowedCellCount = (Integer) configuration.get(CONFIG_MAX_TABLE_CELLS);</span>
      }
    }
<span class="fc" id="L412">    LOG.log(Level.FINEST, &quot;mMaxTableColumnCount{0}&quot;, mMaxAllowedColumnCount);</span>
<span class="fc" id="L413">    LOG.log(Level.FINEST, &quot;mMaxTableRowCount{0}&quot;, mMaxAllowedRowCount);</span>
<span class="fc" id="L414">    LOG.log(Level.FINEST, &quot;mMaxTableCellCount{0}&quot;, mMaxAllowedCellCount);</span>

    // Make the Operation Queue to be created accessible via the Schema Document
<span class="fc" id="L417">    mJsonOperationProducer = mSchemaDoc.getJsonOperationQueue();</span>
<span class="fc bfc" id="L418" title="All 2 branches covered.">    if (mJsonOperationProducer == null) {</span>
      // temporary initiated here as all the tests are not using the OperationTextDocument
<span class="fc" id="L420">      mJsonOperationProducer = new JsonOperationProducer();</span>
<span class="fc" id="L421">      mSchemaDoc.setJsonOperationQueue(mJsonOperationProducer);</span>
    }

<span class="fc" id="L424">    mAutoListStyles = new HashMap&lt;String, TextListStyleElement&gt;();</span>
<span class="fc" id="L425">    mUserFieldDecls = new HashMap&lt;String, TextUserFieldDeclElement&gt;();</span>

    // Stack to remember/track the nested delimiters not being components (spans) open-up by SAX
    // events
<span class="fc" id="L429">    mTextSelectionStack = new ArrayDeque&lt;TextSelection&gt;();</span>
<span class="fc" id="L430">    mListStyleStack = new ArrayDeque&lt;ParagraphListProperties&gt;();</span>
    //        mShapePropertiesStack = new ArrayDeque&lt;ShapeProperties&gt;();
<span class="fc" id="L432">    mWhitespaceStatusStack = new ArrayDeque&lt;WhitespaceStatus&gt;();</span>
<span class="fc" id="L433">  }</span>

  @Override
<span class="fc" id="L436">  public void startDocument() throws SAXException {}</span>

  @Override
<span class="fc" id="L439">  public void endDocument() throws SAXException {}</span>

  /**
   * There are areas that are not allowed to addChild further components beyond. All further
   * operations have to be blocked, but the creation of the DOM tree must not be disturbed.
   */
  private boolean isBlockedSubTree() {
<span class="fc" id="L446">    return mNoOperationsAllowed;</span>
  }

  /**
   * There are areas that are not allowed to addChild further components beyond. All further
   * operations have to be blocked, but the creation of the DOM tree must not be disturbed.
   */
  private boolean checkEndOfBlockedSubTree(String uri, String localName) {

<span class="fc" id="L455">    boolean isBlocked = mNoOperationsAllowed;</span>
<span class="fc bfc" id="L456" title="All 2 branches covered.">    if (mNoOperationsAllowed) {</span>
<span class="fc" id="L457">      isBlocked = isBlockedSubTree(uri, localName, false);</span>
    }
<span class="fc" id="L459">    mElementDepth--;</span>
<span class="fc" id="L460">    return isBlocked;</span>
  }

  private boolean checkStartOfBlockedSubTree(String uri, String localName) {
<span class="fc" id="L464">    mElementDepth++;</span>
<span class="fc" id="L465">    boolean isBlocked = mNoOperationsAllowed;</span>
<span class="fc bfc" id="L466" title="All 2 branches covered.">    if (!mNoOperationsAllowed) {</span>
<span class="fc" id="L467">      isBlocked = isBlockedSubTree(uri, localName, true);</span>
<span class="pc bpc" id="L468" title="1 of 2 branches missed.">    } else if (mIsBlockingFrame) {</span>
<span class="nc bnc" id="L469" title="All 4 branches missed.">      if (mBlockingElementDepth == mElementDepth - 1 &amp;&amp; !localName.equals(&quot;table&quot;)) {</span>
<span class="nc" id="L470">        isBlocked = false;</span>
      } else {
<span class="nc" id="L472">        isBlocked = true;</span>
      }
    }
<span class="fc" id="L475">    return isBlocked;</span>
  }

  // ToDo: Differentiate  if there is a shapeBlock, ImageBlock or ParagraphBlock
  private boolean isBlockedSubTree(String uri, String localName, boolean isStart) {
    // within a paragraph within a paragraph
<span class="fc" id="L481">    boolean isBlocked = mNoOperationsAllowed;</span>
<span class="pc bpc" id="L482" title="1 of 2 branches missed.">    boolean isMasterPage =</span>
        uri != null
<span class="fc bfc" id="L484" title="All 2 branches covered.">            &amp;&amp; uri.equals(StyleMasterPageElement.ELEMENT_NAME.getUri())</span>
<span class="fc bfc" id="L485" title="All 2 branches covered.">            &amp;&amp; localName.equals(StyleMasterPageElement.ELEMENT_NAME.getLocalName());</span>
<span class="fc bfc" id="L486" title="All 2 branches covered.">    if (isStart) {</span>
      // if it is a second text component (ie. text:p or text:h element)
<span class="fc" id="L488">      if (</span>
      /*!mWhitespaceStatusStack.isEmpty() &amp;&amp; Component.isTextComponentRoot(uri, localName) || */ OdfElement
<span class="fc bfc" id="L490" title="All 4 branches covered.">              .isIgnoredElement(uri, localName)</span>
          || ((isMasterPage
<span class="fc bfc" id="L492" title="All 2 branches covered.">                  || Component.isHeaderRoot(uri, localName)</span>
<span class="fc bfc" id="L493" title="All 2 branches covered.">                  || Component.isFooterRoot(uri, localName))</span>
<span class="pc bpc" id="L494" title="1 of 2 branches missed.">              &amp;&amp; OdfDocument.OdfMediaType.TEXT.getMediaTypeString() != mMediaType</span>
<span class="nc bnc" id="L495" title="All 2 branches missed.">              &amp;&amp; OdfDocument.OdfMediaType.SPREADSHEET.getMediaTypeString() != mMediaType)) {</span>
<span class="fc" id="L496">        isBlocked = true;</span>
<span class="fc" id="L497">        mNoOperationsAllowed = true;</span>
<span class="fc" id="L498">        mIsIgnoredElement = true;</span>
<span class="fc" id="L499">        mBlockingElementDepth = mElementDepth;</span>
        // if it is a &lt;draw:frame&gt;
      }
    } else { // if this is the closing event of an element
<span class="pc bpc" id="L503" title="1 of 2 branches missed.">      if (mNoOperationsAllowed) {</span>
<span class="fc bfc" id="L504" title="All 2 branches covered.">        if (mBlockingElementDepth == mElementDepth) {</span>
<span class="pc bpc" id="L505" title="1 of 2 branches missed.">          if (mIsIgnoredElement</span>
                  &amp;&amp; (
                  /*!mWhitespaceStatusStack.isEmpty() &amp;&amp; Component.isTextComponentRoot(uri, localName) || */ OdfElement
<span class="pc bpc" id="L508" title="3 of 4 branches missed.">                      .isIgnoredElement(uri, localName))</span>
              || ((isMasterPage
<span class="nc bnc" id="L510" title="All 2 branches missed.">                      || Component.isHeaderRoot(uri, localName)</span>
<span class="nc bnc" id="L511" title="All 2 branches missed.">                      || Component.isFooterRoot(uri, localName))</span>
<span class="nc bnc" id="L512" title="All 2 branches missed.">                  &amp;&amp; OdfDocument.OdfMediaType.TEXT.getMediaTypeString() != mMediaType</span>
<span class="nc bnc" id="L513" title="All 2 branches missed.">                  &amp;&amp; OdfDocument.OdfMediaType.SPREADSHEET.getMediaTypeString() != mMediaType)) {</span>
<span class="fc" id="L514">            mIsIgnoredElement = false;</span>
<span class="fc" id="L515">            mBlockingElementDepth = -1;</span>
<span class="fc" id="L516">            mNoOperationsAllowed = false;</span>
<span class="fc" id="L517">            isBlocked = true;</span>
            // if it is a &lt;draw:frame&gt;
          }
<span class="pc bpc" id="L520" title="3 of 4 branches missed.">        } else if (mIsBlockingFrame</span>
            &amp;&amp; mBlockingElementDepth == mElementDepth - 1
<span class="nc bnc" id="L522" title="All 2 branches missed.">            &amp;&amp; !localName.equals(&quot;table&quot;)) {</span>
<span class="nc" id="L523">          isBlocked = false;</span>
        }
      } else { // closing will never enabled a blocking
<span class="nc bnc" id="L526" title="All 4 branches missed.">        if (mIsIgnoredElement || mIsBlockingShape) {</span>
          // close this element, but afterwards
<span class="nc" id="L528">          mNoOperationsAllowed = true;</span>
<span class="nc" id="L529">          isBlocked = false;</span>
<span class="nc bnc" id="L530" title="All 2 branches missed.">        } else if (mIsBlockingFrame) {</span>
<span class="nc bnc" id="L531" title="All 4 branches missed.">          if (mBlockingElementDepth == mElementDepth - 1 &amp;&amp; !localName.equals(&quot;table&quot;)) {</span>
<span class="nc" id="L532">            isBlocked = false;</span>
          } else {
<span class="nc" id="L534">            isBlocked = true;</span>
          }
        }
      }
    }
<span class="fc" id="L539">    return isBlocked;</span>
  }

  @Override
  public void startElement(String uri, String localName, String qName, Attributes attributes)
      throws SAXException {
<span class="fc" id="L545">    flushTextAtStart(uri, localName, qName);</span>

    // if there is a specilized handler on the stack, dispatch the event
<span class="fc" id="L548">    OdfElement element = null;</span>
    // ToDo: Should be able to create operations without creating the DOM Tree
    // ToDo: Are there use-cases that text:s still resides in the DOM? if(isWhiteSpaceElement) ??
    // If Paragraph is not being edited, it will be saved as it is..
    if (domCreationEnabled) {
<span class="pc bpc" id="L553" title="1 of 4 branches missed.">      if (uri.equals(Constants.EMPTY_STRING) || qName.equals(Constants.EMPTY_STRING)) {</span>
<span class="fc" id="L554">        element = mFileDom.createElement(localName);</span>
      } else {
        // == correct: if localName is the same object as qName, there is a default namespace set
<span class="pc bpc" id="L557" title="1 of 2 branches missed.">        if (localName == qName) {</span>
<span class="nc" id="L558">          element =</span>
<span class="nc" id="L559">              mFileDom.createElementNS(</span>
<span class="nc" id="L560">                  OdfName.getOdfName(OdfNamespace.newNamespace(null, uri), localName));</span>
        } else {
<span class="fc" id="L562">          element = mFileDom.createElementNS(uri, qName);</span>
        }
      }
<span class="fc" id="L565">      addAttributes(element, attributes);</span>
    }
    // if it is the last page bound object then move all the nodes to a temporary location
<span class="fc bfc" id="L568" title="All 2 branches covered.">    if (mComponentDepth &lt; 0</span>
<span class="pc bpc" id="L569" title="1 of 2 branches missed.">        &amp;&amp; m_cachedPageShapes.size() &gt; 0</span>
<span class="nc bnc" id="L570" title="All 6 branches missed.">        &amp;&amp; (localName.equals(&quot;p&quot;) || localName.equals(&quot;h&quot;) || localName.equals(&quot;table&quot;))) {</span>
      // move nodes
<span class="nc" id="L572">      Node bodyNode = mCurrentNode.getParentNode();</span>
<span class="nc" id="L573">      Iterator&lt;ShapeProperties&gt; it = m_cachedPageShapes.iterator();</span>
<span class="nc bnc" id="L574" title="All 2 branches missed.">      while (it.hasNext()) {</span>
<span class="nc" id="L575">        ShapeProperties component = it.next();</span>
<span class="nc" id="L576">        bodyNode.insertBefore(component.mOwnNode, bodyNode.getFirstChild());</span>
<span class="nc" id="L577">      }</span>
<span class="nc" id="L578">      mLastComponentPositions.clear();</span>
    }
    // Font declarations are before the component
<span class="fc bfc" id="L581" title="All 2 branches covered.">    if (element instanceof StyleFontFaceElement) {</span>
<span class="fc" id="L582">      String fontName = element.getAttributeNS(OdfDocumentNamespace.STYLE.getUri(), &quot;name&quot;);</span>
<span class="pc bpc" id="L583" title="2 of 4 branches missed.">      if (fontName != null &amp;&amp; !fontName.isEmpty()) {</span>
<span class="fc" id="L584">        Set&lt;String&gt; fontNames = ((OdfDocument) mSchemaDoc).getFontNames();</span>
<span class="fc bfc" id="L585" title="All 2 branches covered.">        if (!fontNames.contains(fontName)) {</span>
<span class="fc" id="L586">          mJsonOperationProducer.addFontData(</span>
              fontName,
              null,
<span class="fc" id="L589">              element.getAttributeNS(OdfDocumentNamespace.SVG.getUri(), &quot;font-family&quot;),</span>
<span class="fc" id="L590">              element.getAttributeNS(OdfDocumentNamespace.STYLE.getUri(), &quot;font-family-generic&quot;),</span>
<span class="fc" id="L591">              element.getAttributeNS(OdfDocumentNamespace.STYLE.getUri(), &quot;font-pitch&quot;),</span>
<span class="fc" id="L592">              element.getAttributeNS(OdfDocumentNamespace.SVG.getUri(), &quot;panose-1&quot;));</span>
<span class="fc" id="L593">          fontNames.add(fontName);</span>
        }
      }
    }
<span class="fc bfc" id="L597" title="All 2 branches covered.">    if (element instanceof TextListStyleElement) {</span>
      // We need the reference for later gettin the list styles
<span class="fc" id="L599">      TextListStyleElement listStyle = (TextListStyleElement) element;</span>
<span class="fc" id="L600">      String styleName = listStyle.getAttributeNS(OdfDocumentNamespace.STYLE.getUri(), &quot;name&quot;);</span>
<span class="pc bpc" id="L601" title="2 of 4 branches missed.">      if (styleName != null &amp;&amp; !styleName.isEmpty()) {</span>
<span class="fc" id="L602">        mAutoListStyles.put(styleName, listStyle);</span>
      }
<span class="fc bfc" id="L604" title="All 2 branches covered.">    } else if (element instanceof TextUserFieldDeclElement) {</span>
<span class="fc" id="L605">      TextUserFieldDeclElement fieldDecl = (TextUserFieldDeclElement) element;</span>
<span class="fc" id="L606">      mUserFieldDecls.put(fieldDecl.getAttribute(&quot;text:name&quot;), fieldDecl);</span>
    }
<span class="fc bfc" id="L608" title="All 2 branches covered.">    if (!checkStartOfBlockedSubTree(uri, localName)) {</span>
<span class="fc bfc" id="L609" title="All 2 branches covered.">      if (Component.isComponentRoot(</span>
          uri, localName)) { // || Component.isCoveredComponentRoot(uri, localName)) {

        // It is not allowed to addChild further components..,
        // within a paragraph within a paragraph
        // ToDo ? -- HashMap with KEY - URL+localname, VALUE - ComponentName
<span class="fc bfc" id="L615" title="All 4 branches covered.">        if (element instanceof TextPElement || element instanceof TextHElement) {</span>
          // Paragraphs that are not child of a known component should be ignored, otherwise the
          // client gets into trouble with nested paragraphs
<span class="fc" id="L618">          boolean isNestedParagraph = false;</span>

<span class="pc bpc" id="L620" title="1 of 2 branches missed.">          if (!isNestedParagraph) {</span>
<span class="fc" id="L621">            mComponentDepth++;</span>
<span class="fc" id="L622">            TextParagraphElementBase p = (TextParagraphElementBase) element;</span>
<span class="fc" id="L623">            Map&lt;String, Object&gt; hardFormatting = mJsonOperationProducer.getHardStyles(p);</span>
<span class="fc bfc" id="L624" title="All 2 branches covered.">            if (hardFormatting == null) {</span>
<span class="fc" id="L625">              hardFormatting = new HashMap&lt;String, Object&gt;();</span>
            }
<span class="fc bfc" id="L627" title="All 4 branches covered.">            if (element instanceof TextHElement || !mListStyleStack.isEmpty()) {</span>
<span class="fc bfc" id="L628" title="All 2 branches covered.">              if (!hardFormatting.containsKey(&quot;paragraph&quot;)) {</span>
                // if there are absolute styles, but not the main property set, where the
                // templateStyleId should be placed in
<span class="fc" id="L631">                hardFormatting.put(&quot;paragraph&quot;, new JSONObject());</span>
              }
<span class="fc" id="L633">              JSONObject paraProps = (JSONObject) hardFormatting.get(&quot;paragraph&quot;);</span>

              try {
<span class="fc bfc" id="L636" title="All 2 branches covered.">                if (!mListStyleStack.isEmpty()) {</span>
<span class="fc" id="L637">                  paraProps.put(&quot;listLevel&quot;, mListStyleStack.size() - 1);</span>
                  // Only the first paragraph within a list item should show a label!
<span class="fc" id="L639">                  ParagraphListProperties listProps = mListStyleStack.getLast();</span>
<span class="fc bfc" id="L640" title="All 2 branches covered.">                  if (listProps.hasListLabel()) {</span>
<span class="fc" id="L641">                    listProps.showListLabel(Boolean.FALSE);</span>
                  } else {
<span class="fc" id="L643">                    paraProps.put(&quot;listLabelHidden&quot;, Boolean.TRUE);</span>
                  }
<span class="fc" id="L645">                  String listId = listProps.getListId();</span>
<span class="pc bpc" id="L646" title="1 of 4 branches missed.">                  if (listId != null &amp;&amp; !listId.isEmpty()) {</span>
<span class="fc" id="L647">                    paraProps.put(&quot;listId&quot;, listId);</span>
                  }
<span class="fc" id="L649">                  boolean foundListXmlId = false;</span>
<span class="fc" id="L650">                  boolean foundListItemXmlId = false;</span>
<span class="fc" id="L651">                  Iterator&lt;ParagraphListProperties&gt; listPropsIter =</span>
<span class="fc" id="L652">                      mListStyleStack.descendingIterator();</span>
<span class="fc bfc" id="L653" title="All 6 branches covered.">                  while ((!foundListXmlId || !foundListItemXmlId) &amp;&amp; listPropsIter.hasNext()) {</span>
<span class="fc" id="L654">                    ParagraphListProperties currentListProp = listPropsIter.next();</span>

<span class="fc" id="L656">                    String listXmlId = currentListProp.getListXmlId();</span>
<span class="pc bpc" id="L657" title="2 of 6 branches missed.">                    if (!foundListXmlId &amp;&amp; listXmlId != null &amp;&amp; !listXmlId.isEmpty()) {</span>
<span class="fc" id="L658">                      foundListXmlId = true;</span>
<span class="fc" id="L659">                      paraProps.put(&quot;listXmlId&quot;, listXmlId);</span>
                    }
<span class="fc" id="L661">                    String listItemXmlId = currentListProp.getListItemXmlId();</span>
<span class="pc bpc" id="L662" title="2 of 6 branches missed.">                    if (!foundListItemXmlId &amp;&amp; listItemXmlId != null &amp;&amp; !listItemXmlId.isEmpty()) {</span>
<span class="fc" id="L663">                      foundListItemXmlId = true;</span>
<span class="fc" id="L664">                      paraProps.put(&quot;listItemXmlId&quot;, listItemXmlId);</span>
                    }
<span class="fc" id="L666">                  }</span>

<span class="fc bfc" id="L668" title="All 2 branches covered.">                  if (listProps.isListStart()) {</span>
<span class="fc" id="L669">                    paraProps.put(&quot;listStart&quot;, Boolean.TRUE);</span>
                  }
<span class="fc" id="L671">                  String listStyleId = JsonOperationProducer.getListStyle(mListStyleStack, p);</span>
<span class="pc bpc" id="L672" title="1 of 4 branches missed.">                  if (listStyleId != null &amp;&amp; !listStyleId.isEmpty()) {</span>
<span class="fc" id="L673">                    mJsonOperationProducer.addListStyle(mSchemaDoc, mAutoListStyles, listStyleId);</span>
<span class="fc" id="L674">                    paraProps.put(&quot;listStyleId&quot;, listStyleId);</span>
                  } else {
<span class="fc" id="L676">                    paraProps.put(&quot;listStyleId&quot;, Constants.ODFTK_DEFAULT_LIST);</span>
                  }
<span class="fc bfc" id="L678" title="All 2 branches covered.">                  if (mListStartValue != -1) {</span>
<span class="fc" id="L679">                    paraProps.put(&quot;listStartValue&quot;, mListStartValue);</span>
<span class="fc" id="L680">                    mListStartValue = -1;</span>
                  }
                }
                // Add heading outline numbering
<span class="fc bfc" id="L684" title="All 2 branches covered.">                if (element instanceof TextHElement) {</span>
<span class="fc" id="L685">                  Integer outlineLevel = ((TextHElement) p).getTextOutlineLevelAttribute();</span>
<span class="fc bfc" id="L686" title="All 2 branches covered.">                  if (outlineLevel != null) {</span>
<span class="fc" id="L687">                    paraProps.put(&quot;outlineLevel&quot;, outlineLevel);</span>
                  }
                }
<span class="nc" id="L690">              } catch (JSONException ex) {</span>
<span class="nc" id="L691">                Logger.getLogger(ChangesFileSaxHandler.class.getName()).log(Level.SEVERE, null, ex);</span>
<span class="fc" id="L692">              }</span>
            }

<span class="fc" id="L695">            List&lt;Integer&gt; position = updateComponentPosition();</span>
<span class="fc" id="L696">            OdfStyle templateStyle = p.getDocumentStyle();</span>
<span class="fc" id="L697">            String styleId = null;</span>
<span class="fc bfc" id="L698" title="All 2 branches covered.">            if (templateStyle != null) {</span>
<span class="fc" id="L699">              styleId = templateStyle.getStyleNameAttribute();</span>
<span class="pc bpc" id="L700" title="2 of 4 branches missed.">              if (styleId != null &amp;&amp; !styleId.isEmpty()) {</span>
<span class="fc" id="L701">                hardFormatting.put(OPK_STYLE_ID, styleId);</span>
              }
            }
<span class="fc" id="L704">            mCurrentComponent = mCurrentComponent.createChildComponent(p);</span>
<span class="fc" id="L705">            boolean paragraphOpCreated = false;</span>
<span class="pc bpc" id="L706" title="2 of 4 branches missed.">            if (!mPageBoundObjectsRelocated &amp;&amp; !m_cachedPageShapes.isEmpty()) {</span>
              // first document paragraph might be inside of a table
<span class="nc" id="L708">              boolean isFirstDocumentParagraph =</span>
<span class="nc bnc" id="L709" title="All 4 branches missed.">                  mComponentStack.empty() || mComponentStack.peek() instanceof CachedTable;</span>
<span class="nc bnc" id="L710" title="All 4 branches missed.">              if (isFirstDocumentParagraph &amp;&amp; m_cachedPageShapes.size() &gt; 0) {</span>
<span class="nc" id="L711">                cacheOperation(</span>
                    false,
                    OperationConstants.PARAGRAPH,
                    position,
                    false,
                    hardFormatting,
                    mContextName);
<span class="nc" id="L718">                paragraphOpCreated = true;</span>
<span class="nc" id="L719">                Iterator&lt;ShapeProperties&gt; it = m_cachedPageShapes.iterator();</span>
<span class="nc bnc" id="L720" title="All 2 branches missed.">                while (it.hasNext()) {</span>
<span class="nc" id="L721">                  ShapeProperties component = it.next();</span>
<span class="nc" id="L722">                  Component frameComponent = component.getDrawFrameElement().getComponent();</span>
<span class="nc" id="L723">                  Component frameComponentParent = frameComponent.getParent();</span>
<span class="nc" id="L724">                  int framePosition = frameComponentParent.indexOf(frameComponent);</span>
<span class="nc" id="L725">                  frameComponentParent.remove(framePosition);</span>
<span class="nc" id="L726">                  element.appendChild(component.mOwnNode);</span>
<span class="nc" id="L727">                  component.mShapePosition.addAll(0, position);</span>
<span class="nc" id="L728">                  component.createShapeOperation(</span>
                      this,
                      mComponentStack,
                      component.mDescription,
<span class="nc bnc" id="L732" title="All 2 branches missed.">                      component.hasImageSibling()</span>
<span class="nc" id="L733">                          ? ShapeType.ImageShape</span>
<span class="nc bnc" id="L734" title="All 2 branches missed.">                          : component.isGroupShape() ? ShapeType.GroupShape : ShapeType.NormalShape,</span>
                      component.mContext);
<span class="nc" id="L736">                  Iterator&lt;CachedOperation&gt; opIter = component.iterator();</span>
<span class="nc bnc" id="L737" title="All 2 branches missed.">                  while (opIter.hasNext()) {</span>
<span class="nc" id="L738">                    CachedOperation op = opIter.next();</span>
<span class="nc" id="L739">                    List&lt;Integer&gt; start = op.mStart;</span>
<span class="nc bnc" id="L740" title="All 2 branches missed.">                    if (!op.mAbsolutePosition) {</span>
<span class="nc bnc" id="L741" title="All 2 branches missed.">                      if (op.mComponentType.equals(OperationConstants.ATTRIBUTES)) {</span>
                        @SuppressWarnings(&quot;unchecked&quot;)
<span class="nc" id="L743">                        List&lt;Integer&gt; end = (List&lt;Integer&gt;) op.mComponentProperties[0];</span>
                        // TODO: add _real_ position of the current paragraph (could be in a
                        // table...)
<span class="nc" id="L746">                        end.addAll(0, position);</span>
                      }
                      // TODO: add _real_ position of the current paragraph (could be in a table...)
<span class="nc" id="L749">                      start.addAll(0, position);</span>
                    }
<span class="nc" id="L751">                    cacheOperation(</span>
                        false,
                        op.mComponentType,
                        start,
                        false,
                        op.mHardFormattingProperties,
                        op.mComponentProperties);
<span class="nc" id="L758">                  }</span>
<span class="nc" id="L759">                }</span>
<span class="nc" id="L760">                m_cachedPageShapes.clear();</span>
              }
<span class="nc" id="L762">              mPageBoundObjectsRelocated |= isFirstDocumentParagraph;</span>
            }
<span class="pc bpc" id="L764" title="1 of 2 branches missed.">            if (!paragraphOpCreated) {</span>
<span class="fc" id="L765">              cacheOperation(</span>
                  false,
                  OperationConstants.PARAGRAPH,
                  position,
                  false,
                  hardFormatting,
                  mContextName);
            }

            // For each new paragraph/heading addChild a new context information for their
            // whitespace, required for normalization
<span class="fc" id="L776">            mWhitespaceStatusStack.add(new WhitespaceStatus(false, mComponentDepth));</span>
<span class="fc" id="L777">            element.markAsComponentRoot(true);</span>
            // ToDo: NEW COMPONENTS - SECTION
            //			} else if (element instanceof TextSectionElement) {
            //                mJsonOperationProducer.addChild(&quot;Section&quot;, position);
            //                mCurrentComponent = mCurrentComponent.addChild((TextSectionElement)
            // element);
<span class="fc" id="L783">          } else {</span>
            // a nested text component without known component in-between
            // ignore nested paragraph content
<span class="nc" id="L786">            mWhitespaceStatusStack.add(new WhitespaceStatus(true, mComponentDepth));</span>
<span class="nc" id="L787">            element.ignoredComponent(true);</span>
          }
<span class="fc bfc" id="L789" title="All 2 branches covered.">        } else if (element instanceof DrawFrameElement</span>
<span class="fc bfc" id="L790" title="All 2 branches covered.">            || Component.isShapeElement(uri, localName)) {</span>
<span class="fc" id="L791">          OdfElement shape = element;</span>
<span class="fc" id="L792">          Map&lt;String, Object&gt; hardFormatting = null;</span>
<span class="pc bpc" id="L793" title="1 of 2 branches missed.">          if (element instanceof OdfStyleableShapeElement) {</span>
<span class="fc" id="L794">            hardFormatting = mJsonOperationProducer.getHardStyles((OdfStyleableShapeElement) shape);</span>
          }
<span class="fc bfc" id="L796" title="All 4 branches covered.">          if (hardFormatting == null || !hardFormatting.containsKey(&quot;drawing&quot;)) {</span>
            // if there are absolute styles, but not the main property set, where the
            // templateStyleId should be placed in
<span class="fc bfc" id="L799" title="All 2 branches covered.">            if (hardFormatting == null) {</span>
<span class="fc" id="L800">              hardFormatting = new HashMap&lt;String, Object&gt;();</span>
            }
<span class="fc" id="L802">            hardFormatting.put(&quot;drawing&quot;, new JSONObject());</span>
          }
<span class="fc" id="L804">          JSONObject drawingProps = (JSONObject) hardFormatting.get(&quot;drawing&quot;);</span>
<span class="pc bpc" id="L805" title="1 of 4 branches missed.">          if (hardFormatting == null || !hardFormatting.containsKey(&quot;image&quot;)) {</span>
            // if there are absolute styles, but not the main property set, where the
            // templateStyleId should be placed in
<span class="pc bpc" id="L808" title="1 of 2 branches missed.">            if (hardFormatting == null) {</span>
<span class="nc" id="L809">              hardFormatting = new HashMap&lt;String, Object&gt;();</span>
            }
<span class="fc" id="L811">            hardFormatting.put(&quot;image&quot;, new JSONObject());</span>
          }
<span class="fc" id="L813">          int anchorHorOffset = 0;</span>
<span class="fc" id="L814">          int anchorVertOffset = 0;</span>
<span class="fc" id="L815">          int anchorLayerOrder = 0;</span>
<span class="fc" id="L816">          int width = 0;</span>
<span class="fc" id="L817">          int height = 0;</span>

<span class="pc bpc" id="L819" title="1 of 2 branches missed.">          if (shape instanceof DrawShapeElementBase) {</span>
<span class="fc" id="L820">            Integer zIndex = ((DrawShapeElementBase) shape).getDrawZIndexAttribute();</span>
<span class="fc bfc" id="L821" title="All 2 branches covered.">            if (null != zIndex) {</span>
<span class="fc" id="L822">              anchorLayerOrder = zIndex;</span>
            }
          }

<span class="pc bpc" id="L826" title="2 of 6 branches missed.">          if (element instanceof DrawLineElement</span>
              || element instanceof DrawConnectorElement
              || element instanceof DrawMeasureElement) {
<span class="pc bpc" id="L829" title="1 of 2 branches missed.">            if (shape.hasAttributeNS(OdfDocumentNamespace.SVG.getUri(), &quot;y1&quot;)</span>
<span class="pc bpc" id="L830" title="1 of 2 branches missed.">                &amp;&amp; shape.hasAttributeNS(OdfDocumentNamespace.SVG.getUri(), &quot;x1&quot;)</span>
<span class="pc bpc" id="L831" title="1 of 2 branches missed.">                &amp;&amp; shape.hasAttributeNS(OdfDocumentNamespace.SVG.getUri(), &quot;y2&quot;)</span>
<span class="pc bpc" id="L832" title="1 of 2 branches missed.">                &amp;&amp; shape.hasAttributeNS(OdfDocumentNamespace.SVG.getUri(), &quot;x2&quot;)) {</span>
<span class="fc" id="L833">              int x1 =</span>
<span class="fc" id="L834">                  MapHelper.normalizeLength(</span>
<span class="fc" id="L835">                      shape.getAttributeNS(OdfDocumentNamespace.SVG.getUri(), &quot;x1&quot;));</span>
<span class="fc" id="L836">              int x2 =</span>
<span class="fc" id="L837">                  MapHelper.normalizeLength(</span>
<span class="fc" id="L838">                      shape.getAttributeNS(OdfDocumentNamespace.SVG.getUri(), &quot;x2&quot;));</span>
<span class="fc" id="L839">              int y1 =</span>
<span class="fc" id="L840">                  MapHelper.normalizeLength(</span>
<span class="fc" id="L841">                      shape.getAttributeNS(OdfDocumentNamespace.SVG.getUri(), &quot;y1&quot;));</span>
<span class="fc" id="L842">              int y2 =</span>
<span class="fc" id="L843">                  MapHelper.normalizeLength(</span>
<span class="fc" id="L844">                      shape.getAttributeNS(OdfDocumentNamespace.SVG.getUri(), &quot;y2&quot;));</span>
<span class="fc" id="L845">              anchorHorOffset = Math.min(x1, x2);</span>
<span class="fc" id="L846">              width = Math.abs(x2 - x1) + 1;</span>
<span class="fc" id="L847">              anchorVertOffset = Math.min(y1, y2);</span>
<span class="fc" id="L848">              height = Math.abs(y2 - y1) + 1;</span>
<span class="fc" id="L849">            }</span>

          } else {

<span class="fc bfc" id="L853" title="All 2 branches covered.">            if (shape.hasAttributeNS(OdfDocumentNamespace.SVG.getUri(), &quot;width&quot;)) {</span>
<span class="fc" id="L854">              width =</span>
<span class="fc" id="L855">                  MapHelper.normalizeLength(</span>
<span class="fc" id="L856">                      shape.getAttributeNS(OdfDocumentNamespace.SVG.getUri(), &quot;width&quot;));</span>
            }
<span class="fc bfc" id="L858" title="All 2 branches covered.">            if (shape.hasAttributeNS(OdfDocumentNamespace.SVG.getUri(), &quot;height&quot;)) {</span>
<span class="fc" id="L859">              height =</span>
<span class="fc" id="L860">                  MapHelper.normalizeLength(</span>
<span class="fc" id="L861">                      shape.getAttributeNS(OdfDocumentNamespace.SVG.getUri(), &quot;height&quot;));</span>
            }
<span class="fc bfc" id="L863" title="All 2 branches covered.">            if (shape.hasAttributeNS(OdfDocumentNamespace.SVG.getUri(), &quot;x&quot;)) {</span>
<span class="fc" id="L864">              anchorHorOffset =</span>
<span class="fc" id="L865">                  MapHelper.normalizeLength(</span>
<span class="fc" id="L866">                      shape.getAttributeNS(OdfDocumentNamespace.SVG.getUri(), &quot;x&quot;));</span>
            }
<span class="fc bfc" id="L868" title="All 2 branches covered.">            if (shape.hasAttributeNS(OdfDocumentNamespace.SVG.getUri(), &quot;y&quot;)) {</span>
<span class="fc" id="L869">              anchorVertOffset =</span>
<span class="fc" id="L870">                  MapHelper.normalizeLength(</span>
<span class="fc" id="L871">                      shape.getAttributeNS(OdfDocumentNamespace.SVG.getUri(), &quot;y&quot;));</span>
            }
          }
          try {
<span class="fc bfc" id="L875" title="All 2 branches covered.">            if (height != 0) {</span>
<span class="fc" id="L876">              drawingProps.put(&quot;height&quot;, height);</span>
            }
<span class="fc bfc" id="L878" title="All 2 branches covered.">            if (width != 0) {</span>
<span class="fc" id="L879">              drawingProps.put(&quot;width&quot;, width);</span>
            }
<span class="fc bfc" id="L881" title="All 2 branches covered.">            if (anchorHorOffset != 0) {</span>
<span class="fc" id="L882">              drawingProps.put(&quot;anchorHorOffset&quot;, anchorHorOffset);</span>
<span class="fc" id="L883">              drawingProps.put(&quot;left&quot;, anchorHorOffset);</span>
            }
<span class="fc bfc" id="L885" title="All 2 branches covered.">            if (anchorVertOffset != 0) {</span>
<span class="fc" id="L886">              drawingProps.put(&quot;anchorVertOffset&quot;, anchorVertOffset);</span>
<span class="fc" id="L887">              drawingProps.put(&quot;top&quot;, anchorVertOffset);</span>
            }
<span class="fc bfc" id="L889" title="All 2 branches covered.">            if (anchorLayerOrder != 0) {</span>
<span class="fc" id="L890">              drawingProps.put(&quot;anchorLayerOrder&quot;, anchorLayerOrder);</span>
            }
<span class="nc" id="L892">          } catch (JSONException ex) {</span>
<span class="nc" id="L893">            Logger.getLogger(ChangesFileSaxHandler.class.getName()).log(Level.SEVERE, null, ex);</span>
<span class="fc" id="L894">          }</span>
<span class="fc bfc" id="L895" title="All 2 branches covered.">          if (shape.hasAttributeNS(OdfDocumentNamespace.DRAW.getUri(), &quot;transform&quot;)) {</span>
            try {
<span class="fc" id="L897">              String transform =</span>
<span class="fc" id="L898">                  shape.getAttributeNS(OdfDocumentNamespace.DRAW.getUri(), &quot;transform&quot;);</span>
<span class="fc" id="L899">              int index = transform.indexOf(&quot;translate&quot;);</span>
<span class="pc bpc" id="L900" title="1 of 2 branches missed.">              if (index &gt;= 0) {</span>
<span class="fc" id="L901">                index = transform.indexOf('(', index);</span>
<span class="fc" id="L902">                transform = transform.substring(index, transform.length());</span>
<span class="fc" id="L903">                int separator = transform.indexOf(' ');</span>
<span class="fc" id="L904">                String leftValue = transform.substring(1, separator);</span>
<span class="fc" id="L905">                index = transform.indexOf(')', separator);</span>
<span class="fc" id="L906">                String rightValue = transform.substring(separator + 1, index);</span>
<span class="fc" id="L907">                anchorHorOffset += MapHelper.normalizeLength(leftValue);</span>
<span class="fc" id="L908">                anchorVertOffset += MapHelper.normalizeLength(rightValue);</span>
              }
<span class="pc bpc" id="L910" title="1 of 2 branches missed.">              if (anchorVertOffset != 0) {</span>
<span class="fc" id="L911">                drawingProps.put(&quot;anchorVertOffset&quot;, anchorVertOffset);</span>
              }
<span class="pc bpc" id="L913" title="1 of 2 branches missed.">              if (anchorHorOffset != 0) {</span>
<span class="fc" id="L914">                drawingProps.put(&quot;anchorHorOffset&quot;, anchorHorOffset);</span>
              }
<span class="nc" id="L916">            } catch (IndexOutOfBoundsException ex) {</span>
<span class="nc" id="L917">              Logger.getLogger(ChangesFileSaxHandler.class.getName()).log(Level.SEVERE, null, ex);</span>
<span class="nc" id="L918">            } catch (JSONException ex) {</span>
<span class="nc" id="L919">              Logger.getLogger(ChangesFileSaxHandler.class.getName()).log(Level.SEVERE, null, ex);</span>
<span class="pc" id="L920">            }</span>
          }
          // &lt;attribute name=&quot;text:anchor-type&quot;&gt;
          //	&lt;choice&gt;
          //		&lt;value&gt;page&lt;/value&gt;
          //		&lt;value&gt;frame&lt;/value&gt;
          //		&lt;value&gt;paragraph&lt;/value&gt;
          //		&lt;value&gt;char&lt;/value&gt;
          //		&lt;value&gt;as-char&lt;/value&gt;
          //	&lt;/choice&gt;
          // &lt;/attribute&gt;
          /*	API:
          anchorHorBase:  Horizontal anchor mode:		One of 'margin', 'page', 'column', 'character', 'leftMargin', 'rightMargin', 'insideMargin', or 'outsideMargin'.
          /*
          @text:anchor-type: h=anchorHorBase &amp; v=anchorVerBase
          page		=&gt; h=page	v=page
          frame		=&gt; h=column v=margin
          paragraph	=&gt; h=column v=paragraph
          char		=&gt; h=character v=paragraph
          as-char		=&gt; inline &amp; h &amp; v weglassen*/
<span class="fc bfc" id="L940" title="All 2 branches covered.">          if (shape.hasAttributeNS(OdfDocumentNamespace.TEXT.getUri(), &quot;anchor-type&quot;)) {</span>
            try {
<span class="fc" id="L942">              String anchorVertBase = null;</span>
<span class="fc" id="L943">              String anchorHorBase = null;</span>
<span class="fc" id="L944">              String anchorType =</span>
<span class="fc" id="L945">                  shape.getAttributeNS(OdfDocumentNamespace.TEXT.getUri(), &quot;anchor-type&quot;);</span>
<span class="fc bfc" id="L946" title="All 2 branches covered.">              if (anchorType.equals(&quot;page&quot;)) {</span>
                // Changes API: true: image as character, false: floating mode
<span class="fc" id="L948">                drawingProps.put(&quot;inline&quot;, Boolean.FALSE);</span>
                // page anchor requires page relation
<span class="fc" id="L950">                drawingProps.put(&quot;anchorHorBase&quot;, &quot;page&quot;);</span>
<span class="fc" id="L951">                drawingProps.put(&quot;anchorVertBase&quot;, &quot;page&quot;);</span>
<span class="fc bfc" id="L952" title="All 2 branches covered.">              } else if (anchorType.equals(&quot;frame&quot;)) {</span>
                // Changes API: true: image as character, false: floating mode
<span class="fc" id="L954">                drawingProps.put(&quot;inline&quot;, Boolean.FALSE);</span>
<span class="fc" id="L955">                anchorVertBase = &quot;column&quot;;</span>
<span class="fc" id="L956">                anchorVertBase = &quot;margin&quot;;</span>
<span class="fc bfc" id="L957" title="All 2 branches covered.">              } else if (anchorType.equals(&quot;paragraph&quot;)) {</span>
                // Changes API: true: image as character, false: floating mode
<span class="fc" id="L959">                drawingProps.put(&quot;inline&quot;, Boolean.FALSE);</span>
<span class="fc" id="L960">                anchorHorBase = &quot;column&quot;;</span>
<span class="fc" id="L961">                anchorVertBase = &quot;paragraph&quot;;</span>
<span class="fc bfc" id="L962" title="All 2 branches covered.">              } else if (anchorType.equals(&quot;char&quot;)) {</span>
                // Changes API: true: image as character, true: floating mode
<span class="fc" id="L964">                drawingProps.put(&quot;inline&quot;, Boolean.FALSE);</span>
<span class="fc" id="L965">                anchorHorBase = &quot;character&quot;;</span>
<span class="fc" id="L966">                anchorVertBase = &quot;paragraph&quot;;</span>
<span class="pc bpc" id="L967" title="1 of 2 branches missed.">              } else if (anchorType.equals(&quot;as-char&quot;)) {</span>
                // Changes API: true: image as character, false: floating mode
<span class="fc" id="L969">                drawingProps.put(&quot;inline&quot;, Boolean.TRUE);</span>
              }
<span class="fc bfc" id="L971" title="All 4 branches covered.">              if (anchorVertBase != null &amp;&amp; !drawingProps.has(&quot;anchorVertBase&quot;)) {</span>
<span class="fc" id="L972">                drawingProps.put(&quot;anchorVertBase&quot;, anchorVertBase);</span>
              }
<span class="fc bfc" id="L974" title="All 4 branches covered.">              if (anchorHorBase != null &amp;&amp; !drawingProps.has(&quot;anchorHorBase&quot;)) {</span>
<span class="fc" id="L975">                drawingProps.put(&quot;anchorHorBase&quot;, anchorHorBase);</span>
              }
<span class="nc" id="L977">            } catch (JSONException ex) {</span>
<span class="nc" id="L978">              Logger.getLogger(ChangesFileSaxHandler.class.getName()).log(Level.SEVERE, null, ex);</span>
<span class="fc" id="L979">            }</span>
          }
<span class="fc" id="L981">          hardFormatting.put(&quot;drawing&quot;, drawingProps);</span>

<span class="fc" id="L983">          mComponentDepth++;</span>
<span class="fc" id="L984">          List&lt;Integer&gt; pos = updateComponentPosition();</span>
          // the delay of the operation was not the solution, as the children would be added fist
          // instead a setAttribute would be more appropriate
          // even if there is a automatic style, only the template style is required
<span class="pc bpc" id="L988" title="1 of 2 branches missed.">          if (element instanceof OdfStyleableShapeElement) {</span>
<span class="fc" id="L989">            String styleId = ((OdfStyleableShapeElement) shape).getDocumentStyleName();</span>
<span class="pc bpc" id="L990" title="1 of 4 branches missed.">            if (styleId != null &amp;&amp; !styleId.isEmpty()) {</span>
<span class="fc" id="L991">              hardFormatting.put(OPK_STYLE_ID, styleId);</span>
            }
          }
<span class="fc" id="L994">          ShapeProperties shapeProps = new ShapeProperties(pos, hardFormatting);</span>
          // special handling for frames as together with the image child they are a single user
          // component
<span class="fc bfc" id="L997" title="All 2 branches covered.">          if (element instanceof DrawFrameElement) {</span>
<span class="fc" id="L998">            shapeProps.setDrawFrameElement((DrawFrameElement) shape);</span>
<span class="fc bfc" id="L999" title="All 2 branches covered.">            if (!mComponentStack.isEmpty()) {</span>
<span class="fc" id="L1000">              final CachedComponent comp = mComponentStack.peek();</span>
<span class="fc bfc" id="L1001" title="All 2 branches covered.">              if (comp instanceof ShapeProperties</span>
<span class="fc bfc" id="L1002" title="All 2 branches covered.">                  &amp;&amp; ((ShapeProperties) comp).getDrawFrameElement() != null) {</span>
<span class="fc" id="L1003">                LOG.warning(&quot;Feature 'Frame attached to Frame' yet unsupported&quot;);</span>
              }
<span class="fc" id="L1005">            }</span>
<span class="fc bfc" id="L1006" title="All 2 branches covered.">          } else if (element instanceof DrawGElement) {</span>
<span class="fc" id="L1007">            shapeProps.setGroupShape();</span>
<span class="fc" id="L1008">            element.markAsComponentRoot(true);</span>
          }
<span class="pc bpc" id="L1010" title="1 of 2 branches missed.">          if (mCurrentComponent != null) {</span>
<span class="fc" id="L1011">            mComponentStack.push(shapeProps);</span>
<span class="fc" id="L1012">            mCurrentComponent = mCurrentComponent.createChildComponent(element);</span>
          }
          //                    mShapePropertiesStack.push(shapeProps);

          // table component (table within a text document or a spreadsheet)
<span class="fc bfc" id="L1017" title="All 2 branches covered.">        } else if (element instanceof TableTableElement) {</span>
<span class="fc" id="L1018">          mComponentDepth++;</span>
          // The table will be created with column width, after columns are parsed (just before
          // first row!)
<span class="fc" id="L1021">          updateComponentPosition();</span>
          // tables are not written out directly, but its operation collected and only flushed
          // if they are not exceeding a maximum size

<span class="fc" id="L1025">          isTableNew = true;</span>
<span class="fc" id="L1026">          mTableElement = (TableTableElement) element;</span>
<span class="fc" id="L1027">          mCurrentComponent = mCurrentComponent.createChildComponent(mTableElement);</span>
          // initialize a new list for the relative column widths
          // ToDo: Receive the styles from the root component
          // ToDo: If I do not want a DOM, do I have to parse the styles and addChild them to
          // component?
          //		Do I have to parse the styles.xml first to get the props as maps (hashmaps)?
<span class="fc bfc" id="L1033" title="All 2 branches covered.">          if (mTableElement.hasAttributeNS(OdfDocumentNamespace.TABLE.getUri(), &quot;style-name&quot;)) {</span>
<span class="fc" id="L1034">            mTableHardFormatting = mJsonOperationProducer.getHardStyles(mTableElement);</span>
<span class="fc" id="L1035">            String styleId = mTableElement.getDocumentStyleName();</span>
<span class="pc bpc" id="L1036" title="1 of 4 branches missed.">            if (styleId != null &amp;&amp; !styleId.isEmpty()) {</span>
<span class="pc bpc" id="L1037" title="1 of 2 branches missed.">              if (mTableHardFormatting == null) {</span>
<span class="nc" id="L1038">                mTableHardFormatting = new HashMap&lt;&gt;();</span>
              }
<span class="fc" id="L1040">              mTableHardFormatting.put(OPK_STYLE_ID, styleId);</span>
              //	All ODF styles are hard formatted
              //	JSONObject tableProps = mTableHardFormatting.get(&quot;table&quot;);
              //	mTableHardFormatting.put(&quot;templateStyleId&quot;,
              // table.getDocumentStyle().getStyleNameAttribute());
              //	OdfStyle tableStyle = table.getDocumentStyle();
              //	if(tableStyle != null){
              //	mTableDisplayName = tableStyle.getAttributeNS(OdfDocumentNamespace.STYLE.getUri(),
              // &quot;display-name&quot;);
            }
<span class="fc" id="L1050">          } else {</span>
<span class="fc" id="L1051">            mTableHardFormatting = new HashMap&lt;&gt;();</span>
          }
<span class="fc" id="L1053">          mTableName = mTableElement.getAttributeNS(OdfDocumentNamespace.TABLE.getUri(), &quot;name&quot;);</span>
<span class="fc" id="L1054">          mColumnRelWidths = new LinkedList&lt;&gt;();</span>
<span class="fc" id="L1055">          element.markAsComponentRoot(true);</span>
<span class="fc bfc" id="L1056" title="All 2 branches covered.">        } else if (element instanceof TableTableRowElement) {</span>
<span class="fc" id="L1057">          mComponentDepth++;</span>
<span class="fc bfc" id="L1058" title="All 2 branches covered.">          if (isTableNew) {</span>
            // In case neiter relative nor absolute table column width were given, all column are
            // equal sized (given rel size of '1')
<span class="fc" id="L1061">            mColumnRelWidths = Table.collectColumnWidths(mTableElement, mColumns);</span>
<span class="fc" id="L1062">            mColumns.clear();</span>
<span class="pc bpc" id="L1063" title="1 of 4 branches missed.">            if (mColumnRelWidths != null &amp;&amp; mColumnRelWidths.isEmpty()) {</span>
<span class="fc bfc" id="L1064" title="All 2 branches covered.">              for (int i = 0; i &lt; mColumnCount; i++) {</span>
<span class="fc" id="L1065">                mColumnRelWidths.add(ONE);</span>
              }
            }

            // The grid is known after columns had been parsed, updating later to row positino
<span class="fc" id="L1070">            List&lt;Integer&gt; tablePosition = new LinkedList&lt;Integer&gt;(mLastComponentPositions);</span>
<span class="fc" id="L1071">            cacheTableOperation(</span>
                OperationConstants.TABLE,
                tablePosition,
                mTableHardFormatting,
                mColumnRelWidths,
                mTableName);
<span class="fc" id="L1077">            mTableHardFormatting = null;</span>
<span class="fc" id="L1078">            isTableNew = false;</span>
<span class="fc" id="L1079">            mTableName = null;</span>
<span class="fc" id="L1080">            mColumnCount = 0;</span>
<span class="fc" id="L1081">            mColumnRelWidths = null;</span>
          }
<span class="fc" id="L1083">          List&lt;Integer&gt; position = updateComponentPosition();</span>
<span class="fc" id="L1084">          TableTableRowElement row = (TableTableRowElement) element;</span>
<span class="fc" id="L1085">          mCurrentComponent = mCurrentComponent.createChildComponent(row);</span>
          // repeatition can cause a different positioning
<span class="fc" id="L1087">          int repeatedRows = 1;</span>
<span class="fc bfc" id="L1088" title="All 2 branches covered.">          if (row.hasAttributeNS(OdfDocumentNamespace.TABLE.getUri(), &quot;number-rows-repeated&quot;)) {</span>
<span class="fc" id="L1089">            repeatedRows =</span>
<span class="fc" id="L1090">                Integer.parseInt(</span>
<span class="fc" id="L1091">                    row.getAttributeNS(</span>
<span class="fc" id="L1092">                        OdfDocumentNamespace.TABLE.getUri(), &quot;number-rows-repeated&quot;));</span>
<span class="fc" id="L1093">            mCurrentComponent.hasRepeated(true);</span>
          }
<span class="fc" id="L1095">          boolean isVisible = Boolean.TRUE;</span>
<span class="pc bpc" id="L1096" title="1 of 2 branches missed.">          if (row.hasAttributeNS(OdfDocumentNamespace.TABLE.getUri(), &quot;visibility&quot;)) {</span>
<span class="nc" id="L1097">            isVisible =</span>
<span class="nc" id="L1098">                Constants.VISIBLE.equals(</span>
<span class="nc" id="L1099">                    row.getAttributeNS(OdfDocumentNamespace.TABLE.getUri(), &quot;visibility&quot;));</span>
          }
<span class="fc" id="L1101">          Map&lt;String, Object&gt; hardFormatting = mJsonOperationProducer.getHardStyles(row);</span>
<span class="fc" id="L1102">          OdfStyle templateStyle = row.getDocumentStyle();</span>
<span class="fc" id="L1103">          String styleId = null;</span>
<span class="pc bpc" id="L1104" title="1 of 2 branches missed.">          if (templateStyle != null) {</span>
<span class="nc" id="L1105">            styleId = templateStyle.getStyleNameAttribute();</span>
<span class="nc bnc" id="L1106" title="All 4 branches missed.">            if (styleId != null &amp;&amp; !styleId.isEmpty()) {</span>
<span class="nc" id="L1107">              hardFormatting.put(OPK_STYLE_ID, styleId);</span>
            }
          }
<span class="pc bpc" id="L1110" title="1 of 2 branches missed.">          if (!isVisible) {</span>
            JSONObject rowProps;
<span class="nc bnc" id="L1112" title="All 2 branches missed.">            if (hardFormatting == null) {</span>
              // if there are absolute styles, but not the main property set, where the
              // templateStyleId should be placed in
<span class="nc bnc" id="L1115" title="All 2 branches missed.">              if (hardFormatting == null) {</span>
<span class="nc" id="L1116">                hardFormatting = new HashMap&lt;String, Object&gt;();</span>
              }
            }
<span class="nc bnc" id="L1119" title="All 2 branches missed.">            if (!hardFormatting.containsKey(&quot;row&quot;)) {</span>
<span class="nc" id="L1120">              rowProps = new JSONObject();</span>
<span class="nc" id="L1121">              hardFormatting.put(&quot;row&quot;, rowProps);</span>
            } else {
<span class="nc" id="L1123">              rowProps = (JSONObject) hardFormatting.get(&quot;row&quot;);</span>
<span class="nc bnc" id="L1124" title="All 2 branches missed.">              if (rowProps == null) {</span>
<span class="nc" id="L1125">                rowProps = new JSONObject();</span>
              }
            }
            try {
<span class="nc" id="L1129">              rowProps.put(&quot;visible&quot;, Boolean.FALSE);</span>
<span class="nc" id="L1130">            } catch (JSONException ex) {</span>
<span class="nc" id="L1131">              Logger.getLogger(ChangesFileSaxHandler.class.getName()).log(Level.SEVERE, null, ex);</span>
<span class="nc" id="L1132">            }</span>
          }
<span class="fc" id="L1134">          cacheTableOperation(OperationConstants.ROWS, position, hardFormatting, repeatedRows);</span>
<span class="fc" id="L1135">          element.markAsComponentRoot(true);</span>
<span class="pc bpc" id="L1136" title="1 of 4 branches missed.">        } else if (element instanceof TableTableCellElement</span>
            || element instanceof TableCoveredTableCellElement) {
<span class="fc" id="L1138">          boolean covered = element instanceof TableCoveredTableCellElement;</span>
<span class="fc" id="L1139">          mComponentDepth++;</span>
<span class="pc bpc" id="L1140" title="1 of 2 branches missed.">          TableTableCellElement cell = covered ? null : (TableTableCellElement) element;</span>
<span class="pc bpc" id="L1141" title="1 of 2 branches missed.">          if (cell != null) {</span>
<span class="fc" id="L1142">            mCurrentComponent = mCurrentComponent.createChildComponent(cell);</span>
          } else {
<span class="nc" id="L1144">            mCurrentComponent = mCurrentComponent.createChildComponent(element);</span>
          }

<span class="fc" id="L1147">          CachedTable cachedTableOps = (CachedTable) mComponentStack.peek();</span>
<span class="fc" id="L1148">          cachedTableOps.setCellRepetition(1);</span>
<span class="fc" id="L1149">          int repetition = 1;</span>
<span class="fc" id="L1150">          Map&lt;String, Object&gt; hardFormatting = null;</span>
<span class="pc bpc" id="L1151" title="1 of 2 branches missed.">          if (!covered) {</span>
<span class="fc" id="L1152">            hardFormatting = mJsonOperationProducer.getHardStyles(cell);</span>
          }
          // repeatition and covering can cause a different positioning
          // ToDo: To make DOM optional, work on the component instead of the element. Check
          // directly SAX attributes parameter!
<span class="fc bfc" id="L1157" title="All 2 branches covered.">          if (element.hasAttributeNS(</span>
<span class="fc" id="L1158">              OdfDocumentNamespace.TABLE.getUri(), &quot;number-columns-repeated&quot;)) {</span>
            // cellProps.put(&quot;repeatedColumns&quot;,
            // cell.getAttributeNS(OdfDocumentNamespace.TABLE.getUri(),
            // &quot;number-columns-repeatedColumns&quot;));
<span class="fc" id="L1162">            cachedTableOps.setCellRepetition(</span>
<span class="fc" id="L1163">                Integer.parseInt(</span>
<span class="fc" id="L1164">                    element.getAttributeNS(</span>
<span class="fc" id="L1165">                        OdfDocumentNamespace.TABLE.getUri(), &quot;number-columns-repeated&quot;)));</span>
<span class="fc" id="L1166">            repetition =</span>
<span class="fc" id="L1167">                Integer.parseInt(</span>
<span class="fc" id="L1168">                    element.getAttributeNS(</span>
<span class="fc" id="L1169">                        OdfDocumentNamespace.TABLE.getUri(), &quot;number-columns-repeated&quot;));</span>
<span class="fc" id="L1170">            mCurrentComponent.hasRepeated(true);</span>
          }
<span class="pc bpc" id="L1172" title="1 of 4 branches missed.">          if (cell != null &amp;&amp; cell.hasAttributes()) {</span>
            try {
              // if there are absolute styles, but not the main property set, where the
              // templateStyleId should be placed in
<span class="fc bfc" id="L1176" title="All 4 branches covered.">              if (hardFormatting == null || !hardFormatting.containsKey(&quot;cell&quot;)) {</span>
<span class="fc bfc" id="L1177" title="All 2 branches covered.">                if (hardFormatting == null) {</span>
<span class="fc" id="L1178">                  hardFormatting = new HashMap&lt;String, Object&gt;();</span>
                }
              }
<span class="fc" id="L1181">              JSONObject cellProps = (JSONObject) hardFormatting.get(&quot;cell&quot;);</span>
<span class="fc bfc" id="L1182" title="All 2 branches covered.">              if (cellProps == null) {</span>
<span class="fc" id="L1183">                cellProps = new JSONObject();</span>
              }
<span class="fc bfc" id="L1185" title="All 2 branches covered.">              if (cell.hasAttributeNS(</span>
<span class="fc" id="L1186">                  OdfDocumentNamespace.TABLE.getUri(), &quot;number-columns-spanned&quot;)) {</span>
<span class="fc" id="L1187">                cellProps.put(</span>
                    COLUMN_SPAN,
<span class="fc" id="L1189">                    Integer.parseInt(</span>
<span class="fc" id="L1190">                        cell.getAttributeNS(</span>
<span class="fc" id="L1191">                            OdfDocumentNamespace.TABLE.getUri(), &quot;number-columns-spanned&quot;)));</span>
              }
<span class="fc bfc" id="L1193" title="All 2 branches covered.">              if (cell.hasAttributeNS(OdfDocumentNamespace.TABLE.getUri(), &quot;number-rows-spanned&quot;)) {</span>
<span class="fc" id="L1194">                cellProps.put(</span>
                    ROW_SPAN,
<span class="fc" id="L1196">                    Integer.parseInt(</span>
<span class="fc" id="L1197">                        cell.getAttributeNS(</span>
<span class="fc" id="L1198">                            OdfDocumentNamespace.TABLE.getUri(), &quot;number-rows-spanned&quot;)));</span>
              }
<span class="fc bfc" id="L1200" title="All 2 branches covered.">              if (cellProps.length() != 0) {</span>
<span class="fc" id="L1201">                hardFormatting.put(&quot;cell&quot;, cellProps);</span>
              }
<span class="nc" id="L1203">            } catch (JSONException ex) {</span>
<span class="nc" id="L1204">              Logger.getLogger(ChangesFileSaxHandler.class.getName()).log(Level.SEVERE, null, ex);</span>
<span class="fc" id="L1205">            }</span>
          }
<span class="fc" id="L1207">          List&lt;Integer&gt; position = updateComponentPosition();</span>
<span class="pc bpc" id="L1208" title="1 of 2 branches missed.">          OdfStyle templateStyle = covered ? null : cell.getDocumentStyle();</span>
<span class="pc bpc" id="L1209" title="1 of 2 branches missed.">          if (templateStyle != null) {</span>
<span class="nc" id="L1210">            String styleId = templateStyle.getStyleNameAttribute();</span>
<span class="nc bnc" id="L1211" title="All 4 branches missed.">            if (styleId != null &amp;&amp; !styleId.isEmpty()) {</span>
<span class="nc" id="L1212">              hardFormatting.put(OPK_STYLE_ID, styleId);</span>
            }
          }
<span class="fc" id="L1215">          cacheTableOperation(</span>
<span class="fc" id="L1216">              OperationConstants.CELLS, position, hardFormatting, mCurrentComponent, repetition);</span>
<span class="fc" id="L1217">          element.markAsComponentRoot(true);</span>
<span class="fc bfc" id="L1218" title="All 2 branches covered.">        } else if (element instanceof TextLineBreakElement) {</span>
<span class="fc" id="L1219">          mComponentDepth++;</span>
<span class="fc" id="L1220">          TextLineBreakElement lineBreak = (TextLineBreakElement) element;</span>
<span class="fc" id="L1221">          List&lt;Integer&gt; position = updateComponentPosition();</span>
<span class="fc" id="L1222">          mCurrentComponent = mCurrentComponent.createChildComponent(lineBreak);</span>
<span class="fc" id="L1223">          cacheOperation(false, OperationConstants.LINE_BREAK, position, false, null, null, null);</span>
<span class="fc" id="L1224">          element.markAsComponentRoot(true);</span>
<span class="fc bfc" id="L1225" title="All 2 branches covered.">        } else if (element instanceof TextTabElement) {</span>
<span class="fc" id="L1226">          mComponentDepth++;</span>
<span class="fc" id="L1227">          TextTabElement tab = (TextTabElement) element;</span>
<span class="fc" id="L1228">          List&lt;Integer&gt; position = updateComponentPosition();</span>
<span class="fc" id="L1229">          mCurrentComponent = mCurrentComponent.createChildComponent(tab);</span>
<span class="fc" id="L1230">          cacheOperation(false, OperationConstants.TAB, position, false, null, null, null);</span>
<span class="fc" id="L1231">          element.markAsComponentRoot(true);</span>
<span class="fc bfc" id="L1232" title="All 2 branches covered.">        } else if (Component.isField(uri, localName)) {</span>
<span class="fc" id="L1233">          mComponentDepth++;</span>
<span class="fc" id="L1234">          List&lt;Integer&gt; position = updateComponentPosition();</span>
<span class="fc" id="L1235">          mCurrentComponent = mCurrentComponent.createChildComponent(element);</span>
<span class="fc" id="L1236">          TextFieldSelection selection = null;</span>
<span class="fc bfc" id="L1237" title="All 2 branches covered.">          if (element.hasAttributeNS(LIBRE_OFFICE_MS_INTEROP_NAMESPACE, &quot;type&quot;)</span>
              &amp;&amp; element
<span class="fc" id="L1239">                  .getAttributeNS(LIBRE_OFFICE_MS_INTEROP_NAMESPACE, &quot;type&quot;)</span>
<span class="pc bpc" id="L1240" title="1 of 2 branches missed.">                  .equals(LIBRE_OFFICE_MS_INTEROP_TYPE_CHECKBOX)) {</span>
<span class="fc" id="L1241">            selection =</span>
                new TextFieldSelection(element, position, LIBRE_OFFICE_MS_INTEROP_CHECKBOX_UNICODE);
          } else {
<span class="fc bfc" id="L1244" title="All 2 branches covered.">            if (mFileDom instanceof OdfContentDom) {</span>
<span class="fc" id="L1245">              selection =</span>
                  new TextFieldSelection(
                      element,
                      position,
<span class="fc" id="L1249">                      ((OdfContentDom) mFileDom).getAutomaticStyles(),</span>
                      mUserFieldDecls);
            } else {
<span class="fc" id="L1252">              selection =</span>
                  new TextFieldSelection(
                      element,
                      position,
<span class="fc" id="L1256">                      ((OdfStylesDom) mFileDom).getAutomaticStyles(),</span>
                      mUserFieldDecls);
            }

            // kann auch (OdfStylesDom) sein!
            //                        element.getParentNode();
            //                       TextTimeElement telem = (TextTimeElement)element;
            //                       Map&lt;String, Object&gt; hardFormatting =
            // mJsonOperationProducer.getHardStyles(telem);
          }
<span class="fc" id="L1266">          mTextSelectionStack.add(selection);</span>
<span class="fc bfc" id="L1267" title="All 2 branches covered.">        } else if (element instanceof OfficeAnnotationElement) {</span>
<span class="fc" id="L1268">          ++mComponentDepth;</span>
<span class="pc bpc" id="L1269" title="1 of 2 branches missed.">          if (mIsCharsBeginning) {</span>
<span class="fc" id="L1270">            updateTextPosition();</span>
          }
<span class="fc" id="L1272">          mCurrentComponent = mCurrentComponent.createChildComponent(element);</span>
<span class="fc" id="L1273">          String annotationName = ((OfficeAnnotationElement) element).getOfficeNameAttribute();</span>
<span class="fc bfc" id="L1274" title="All 2 branches covered.">          if (annotationName == null) {</span>
            // annotations without range don't have a name attribute
<span class="fc" id="L1276">            annotationName = ((OdfDocument) mSchemaDoc).getUniqueAnnotationName();</span>
          }
<span class="fc" id="L1278">          CommentComponent commentProps =</span>
              new CommentComponent(mLastComponentPositions, annotationName);
<span class="fc" id="L1280">          ((OdfDocument) mSchemaDoc)</span>
<span class="fc" id="L1281">              .addAnnotation(annotationName, ((OfficeAnnotationElement) element));</span>

<span class="fc" id="L1283">          mComponentStack.push(commentProps);</span>
<span class="fc" id="L1284">          element.markAsComponentRoot(true);</span>
<span class="pc bpc" id="L1285" title="1 of 2 branches missed.">        } else if (element instanceof OfficeAnnotationEndElement) {</span>
<span class="fc" id="L1286">          mComponentDepth++;</span>
<span class="fc" id="L1287">          List&lt;Integer&gt; position = updateComponentPosition();</span>
<span class="fc" id="L1288">          String id = COMMENT_PREFIX;</span>
<span class="fc" id="L1289">          id += ((OfficeAnnotationEndElement) element).getOfficeNameAttribute();</span>
<span class="fc" id="L1290">          cacheOperation(</span>
              false, OperationConstants.COMMENTRANGE, position, false, null, id, mContextName);
<span class="fc" id="L1292">          mCurrentComponent = mCurrentComponent.createChildComponent(element);</span>
<span class="fc" id="L1293">          element.markAsComponentRoot(true);</span>
<span class="fc" id="L1294">        } else {</span>
<span class="nc" id="L1295">          mComponentDepth++;</span>
<span class="nc" id="L1296">          element.markAsComponentRoot(true);</span>
        }

<span class="fc bfc" id="L1299" title="All 2 branches covered.">      } else if (element instanceof TextSpanElement) {</span>
        // Span &lt;text:span&gt; will be triggering an operation after the text content is parsed
<span class="fc" id="L1301">        TextSpanSelection selection =</span>
<span class="fc" id="L1302">            new TextSpanSelection((TextSpanElement) element, getTextPosition());</span>
<span class="fc" id="L1303">        mTextSelectionStack.add(selection);</span>
<span class="fc bfc" id="L1304" title="All 2 branches covered.">      } else if (element instanceof TextAElement) {</span>
<span class="fc" id="L1305">        TextHyperlinkSelection selection =</span>
<span class="fc" id="L1306">            new TextHyperlinkSelection((TextAElement) element, getTextPosition());</span>
<span class="fc" id="L1307">        mTextSelectionStack.add(selection);</span>
<span class="fc bfc" id="L1308" title="All 2 branches covered.">      } else if (element</span>
          instanceof
          TextSElement) { // IMPROVABLE: Currently no component, as it will be removed anyway and
        // would burden removal from automatic path counting
<span class="fc" id="L1312">        mComponentDepth++;</span>
<span class="fc" id="L1313">        List&lt;Integer&gt; position = updateComponentPosition();</span>
<span class="pc bpc" id="L1314" title="1 of 2 branches missed.">        if (mIsCharsBeginning) {</span>
<span class="fc" id="L1315">          mCharsStartPosition = position;</span>
<span class="fc" id="L1316">          mIsCharsBeginning = false;</span>
        }
        // No operation triggering as client knows only space characters. We keep the
        // parsing/mapping to the more performant server
<span class="fc" id="L1320">        TextSElement spaces = (TextSElement) element;</span>
<span class="fc" id="L1321">        mCurrentComponent = mCurrentComponent.createChildComponent(spaces);</span>
<span class="fc" id="L1322">        Integer quantity = spaces.getTextCAttribute();</span>
<span class="fc bfc" id="L1323" title="All 2 branches covered.">        if (quantity == null) {</span>
<span class="fc" id="L1324">          addText(/*mCachedTableOps, */ &quot;\u0020&quot;);</span>
          // mCharsForOperation.append('\u0020');
        } else {
<span class="fc bfc" id="L1327" title="All 2 branches covered.">          for (int i = 0; i &lt; quantity; i++) {</span>
<span class="fc" id="L1328">            mCharsForOperation.append('\u0020');</span>
          }
<span class="fc" id="L1330">          addText(/*mCachedTableOps, */ mCharsForOperation);</span>
        }

<span class="fc bfc" id="L1333" title="All 2 branches covered.">      } else if (element instanceof TableTableColumnElement) {</span>
        // Columns can be grouped by &lt;table:table-columns&gt; and &lt;table:table-column-group&gt;, these
        // would addChild metadata to the following columns
        // Column command should be triggered when one of the grouping starts or closes or if the
        // first row arrives
<span class="fc" id="L1338">        TableTableColumnElement column = (TableTableColumnElement) element;</span>
        // Adjust Column Count
<span class="fc" id="L1340">        mColumnCount++;</span>
<span class="fc" id="L1341">        int repeatedColumns = 1;</span>
<span class="fc bfc" id="L1342" title="All 2 branches covered.">        if (column.hasAttributeNS(OdfDocumentNamespace.TABLE.getUri(), &quot;number-columns-repeated&quot;)) {</span>
<span class="fc" id="L1343">          repeatedColumns =</span>
<span class="fc" id="L1344">              Integer.parseInt(</span>
<span class="fc" id="L1345">                  column.getAttributeNS(</span>
<span class="fc" id="L1346">                      OdfDocumentNamespace.TABLE.getUri(), &quot;number-columns-repeated&quot;));</span>
<span class="fc bfc" id="L1347" title="All 2 branches covered.">          if (repeatedColumns &gt; 1) {</span>
<span class="fc" id="L1348">            mColumnCount += (repeatedColumns - 1);</span>
          }
        }
<span class="fc bfc" id="L1351" title="All 2 branches covered.">        if (mColumns == null) {</span>
<span class="fc" id="L1352">          mColumns = new ArrayList&lt;TableTableColumnElement&gt;();</span>
        }
<span class="fc" id="L1354">        mColumns.add(column);</span>
<span class="fc bfc" id="L1355" title="All 2 branches covered.">      } else if (element instanceof TextListElement) {</span>
<span class="fc" id="L1356">        TextListElement list = (TextListElement) element;</span>
        // in case it is a new list
<span class="fc bfc" id="L1358" title="All 2 branches covered.">        if (mListStyleStack.isEmpty()) {</span>
          // Add always a style, so it can be popped of the stack EVERY time a list element ends
<span class="fc" id="L1360">          ParagraphListProperties paragraphListProps = new ParagraphListProperties();</span>
<span class="fc" id="L1361">          paragraphListProps.setListStart(true);</span>

          // There are two continuation mechanisms for lists in ODF.
          // ODF 1.0/1.1 uses @text:continue-numbering using true/false
          // ODF 1.2 added @text:continue-list using an IDRef to an xml:id of another list.
<span class="fc" id="L1366">          String continuedListId = list.getTextContinueListAttribute();</span>
<span class="fc" id="L1367">          String listXmlId = list.getXmlIdAttribute();</span>
<span class="pc bpc" id="L1368" title="1 of 4 branches missed.">          if (continuedListId != null &amp;&amp; !continuedListId.isEmpty()) {</span>
<span class="fc" id="L1369">            paragraphListProps.setListId(newContinuedList(continuedListId, listXmlId).getListId());</span>
<span class="pc bpc" id="L1370" title="1 of 4 branches missed.">          } else if (listXmlId != null &amp;&amp; !listXmlId.isEmpty()) {</span>
<span class="fc" id="L1371">            paragraphListProps.setListId(newContinuedList(listXmlId).getListId());</span>
          }
<span class="pc bpc" id="L1373" title="1 of 4 branches missed.">          if (listXmlId != null &amp;&amp; !listXmlId.isEmpty()) {</span>
<span class="fc" id="L1374">            paragraphListProps.setListXmlId(listXmlId);</span>
          } else {
<span class="fc" id="L1376">            paragraphListProps.setListXmlId(null);</span>
          }
<span class="fc" id="L1378">          mListStyleStack.add(paragraphListProps);</span>
<span class="fc" id="L1379">        } else {</span>
          // Add always a style, so it can be popped of the stack EVERY time a list element ends
<span class="fc" id="L1381">          mListStyleStack.add(new ParagraphListProperties());</span>
        }

        // @text:continue-numbering LATER
        // @text:continue-list LATER
        // @xml-id - LATER
        // @text:style-name is the given list style unless overwritten by a decendent list
        //	Check if the list style was used already in the document,
        //	if not, map the list properties. Check first in auto than in template.
        //	(Due to MSO issue the style might be even in auto in styles.xml - shall I move them back
        // to content?)
<span class="fc bfc" id="L1392" title="All 2 branches covered.">        if (list.hasAttributeNS(OdfDocumentNamespace.TEXT.getUri(), &quot;style-name&quot;)) {</span>
<span class="fc" id="L1393">          String listStyle = list.getAttributeNS(OdfDocumentNamespace.TEXT.getUri(), &quot;style-name&quot;);</span>
<span class="fc" id="L1394">          mListStyleStack.getLast().setListStyleName(listStyle);</span>
        }
<span class="fc bfc" id="L1396" title="All 4 branches covered.">      } else if (element instanceof TextListItemElement</span>
          || element instanceof TextListHeaderElement) {
<span class="fc" id="L1398">        ParagraphListProperties paragraphListStyle = mListStyleStack.getLast();</span>
<span class="fc" id="L1399">        OdfElement listItem = element;</span>
<span class="fc bfc" id="L1400" title="All 2 branches covered.">        if (listItem instanceof TextListHeaderElement) {</span>
          // list header never show a label
<span class="fc" id="L1402">          paragraphListStyle.showListLabel(false);</span>
        } else {
          // As a new list item starts, the next paragraph needs to provide the list label
<span class="fc" id="L1405">          paragraphListStyle.showListLabel(true);</span>
        }
        //	@text:start-value is provided to the first paragraph only
<span class="fc bfc" id="L1408" title="All 2 branches covered.">        if (listItem.hasAttributeNS(OdfDocumentNamespace.TEXT.getUri(), &quot;start-value&quot;)) {</span>
<span class="fc" id="L1409">          mListStartValue =</span>
<span class="fc" id="L1410">              Integer.parseInt(</span>
<span class="fc" id="L1411">                  listItem.getAttributeNS(OdfDocumentNamespace.TEXT.getUri(), &quot;start-value&quot;));</span>
        }
        //	@text:style-override overrides within this list item the list style
<span class="fc bfc" id="L1414" title="All 2 branches covered.">        if (listItem.hasAttributeNS(OdfDocumentNamespace.TEXT.getUri(), &quot;style-override&quot;)) {</span>
<span class="fc" id="L1415">          String styleOverride =</span>
<span class="fc" id="L1416">              listItem.getAttributeNS(OdfDocumentNamespace.TEXT.getUri(), &quot;style-override&quot;);</span>
<span class="pc bpc" id="L1417" title="2 of 4 branches missed.">          if (styleOverride != null &amp;&amp; !styleOverride.isEmpty()) {</span>
<span class="fc" id="L1418">            paragraphListStyle.overrideListStyle(styleOverride);</span>
          } else {
<span class="nc" id="L1420">            paragraphListStyle.overrideListStyle(null);</span>
          }
<span class="fc" id="L1422">        } else {</span>
<span class="fc" id="L1423">          paragraphListStyle.overrideListStyle(null);</span>
        }
        //  @xml-id
<span class="fc" id="L1426">        String listXmlId = null;</span>
<span class="fc bfc" id="L1427" title="All 2 branches covered.">        if (listItem instanceof TextListItemElement) {</span>
<span class="fc" id="L1428">          listXmlId = ((TextListItemElement) listItem).getXmlIdAttribute();</span>
<span class="pc bpc" id="L1429" title="1 of 2 branches missed.">        } else if (listItem instanceof TextListHeaderElement) {</span>
<span class="fc" id="L1430">          listXmlId = ((TextListHeaderElement) listItem).getXmlIdAttribute();</span>
        }
<span class="pc bpc" id="L1432" title="1 of 4 branches missed.">        if (listXmlId != null &amp;&amp; !listXmlId.isEmpty()) {</span>
<span class="fc" id="L1433">          mListStyleStack.getLast().setListItemXmlId(listXmlId);</span>
        } else {
<span class="fc" id="L1435">          mListStyleStack.getLast().setListItemXmlId(null);</span>
        }
        //		&lt;style:master-page style:name=&quot;Standard&quot; style:page-layout-name=&quot;Mpm1&quot;&gt;
<span class="fc bfc" id="L1438" title="All 2 branches covered.">      } else if (element instanceof StyleMasterPageElement) {</span>
<span class="fc" id="L1439">        StyleMasterPageElement masterPage = (StyleMasterPageElement) element;</span>
<span class="fc" id="L1440">        mMasterPageStyleName = masterPage.getStyleNameAttribute();</span>
<span class="fc" id="L1441">        mPageLayoutName = masterPage.getStylePageLayoutNameAttribute();</span>
<span class="fc" id="L1442">        footerAttrs = headerAttrs = null;</span>
<span class="fc bfc" id="L1443" title="All 2 branches covered.">        if (mPageLayoutName != null) {</span>
          OdfStylesDom stylesDom;
          try {
<span class="fc" id="L1446">            stylesDom = mSchemaDoc.getStylesDom();</span>
<span class="fc" id="L1447">            OdfOfficeAutomaticStyles autoStyles = stylesDom.getAutomaticStyles();</span>
<span class="pc bpc" id="L1448" title="1 of 2 branches missed.">            if (autoStyles != null) {</span>

<span class="fc" id="L1450">              OdfStylePageLayout pageLayout = autoStyles.getPageLayout(mPageLayoutName);</span>
<span class="pc bpc" id="L1451" title="1 of 2 branches missed.">              if (pageLayout != null) {</span>
<span class="fc" id="L1452">                mPageStyleUsage = pageLayout.getStylePageUsageAttribute();</span>
<span class="fc" id="L1453">                headerAttrs =</span>
<span class="fc" id="L1454">                    getHeaderFooterAttrs(</span>
                        (OdfElement)
<span class="fc" id="L1456">                            pageLayout.getChildElement(</span>
<span class="fc" id="L1457">                                StyleHeaderStyleElement.ELEMENT_NAME.getUri(), &quot;header-style&quot;));</span>
<span class="fc" id="L1458">                footerAttrs =</span>
<span class="fc" id="L1459">                    getHeaderFooterAttrs(</span>
                        (OdfElement)
<span class="fc" id="L1461">                            pageLayout.getChildElement(</span>
<span class="fc" id="L1462">                                StyleFooterStyleElement.ELEMENT_NAME.getUri(), &quot;footer-style&quot;));</span>
              }
            }
<span class="nc" id="L1465">          } catch (IOException ex) {</span>
<span class="nc" id="L1466">            Logger.getLogger(ChangesFileSaxHandler.class.getName()).log(Level.SEVERE, null, ex);</span>
<span class="fc" id="L1467">          }</span>
        }
<span class="fc" id="L1469">        String nextMasterPageStyle = masterPage.getStyleNextStyleNameAttribute();</span>
<span class="pc bpc" id="L1470" title="1 of 4 branches missed.">        if (nextMasterPageStyle != null &amp;&amp; !nextMasterPageStyle.isEmpty()) {</span>
<span class="fc" id="L1471">          mHasNextMasterPage = true;</span>
        } else {
<span class="fc" id="L1473">          mHasNextMasterPage = false;</span>
        }

<span class="fc bfc" id="L1476" title="All 2 branches covered.">      } else if (Component.isHeaderRoot(uri, localName)) {</span>
<span class="fc" id="L1477">        PageArea pageArea = null;</span>
<span class="fc bfc" id="L1478" title="All 2 branches covered.">        if (localName.equals(&quot;header&quot;)) {</span>
<span class="fc" id="L1479">          pageArea = HEADER_DEFAULT;</span>
<span class="fc bfc" id="L1480" title="All 2 branches covered.">        } else if (localName.equals(&quot;header-left&quot;)) {</span>
<span class="fc" id="L1481">          pageArea = HEADER_EVEN;</span>
        } else {
<span class="fc" id="L1483">          pageArea = HEADER_FIRST;</span>
        }
<span class="fc" id="L1485">        mContextName = pageArea.getPageAreaName() + CONTEXT_DELIMITER + mMasterPageStyleName;</span>
        // insert the Header style
        // {&quot;name&quot;:&quot;addHeaderFooter&quot;,&quot;id&quot;:&quot;Standard_header_default&quot;,&quot;type&quot;:&quot;header_default&quot;}
<span class="fc" id="L1488">        mJsonOperationProducer.addHeaderFooter(mContextName, pageArea, headerAttrs);</span>
<span class="fc bfc" id="L1489" title="All 2 branches covered.">      } else if (Component.isFooterRoot(uri, localName)) {</span>
        // insert the Footer style
<span class="fc" id="L1491">        PageArea pageArea = null;</span>
<span class="fc bfc" id="L1492" title="All 2 branches covered.">        if (localName.equals(&quot;footer&quot;)) {</span>
<span class="fc" id="L1493">          pageArea = FOOTER_DEFAULT;</span>
<span class="fc bfc" id="L1494" title="All 2 branches covered.">        } else if (localName.equals(&quot;footer-left&quot;)) {</span>
<span class="fc" id="L1495">          pageArea = FOOTER_EVEN;</span>
        } else {
<span class="fc" id="L1497">          pageArea = FOOTER_FIRST;</span>
        }
<span class="fc" id="L1499">        mContextName = pageArea.getPageAreaName() + CONTEXT_DELIMITER + mMasterPageStyleName;</span>
<span class="fc" id="L1500">        mJsonOperationProducer.addHeaderFooter(mContextName, pageArea, footerAttrs);</span>
<span class="fc bfc" id="L1501" title="All 2 branches covered.">      } else if (element instanceof DrawImageElement) {</span>
<span class="fc" id="L1502">        DrawImageElement image = (DrawImageElement) element;</span>
<span class="fc" id="L1503">        ShapeProperties frameProps = (ShapeProperties) mComponentStack.peek();</span>
        //                ShapeProperties frameProps = mShapePropertiesStack.peekFirst();
<span class="fc" id="L1505">        int childNo = frameProps.incrementChildNumber();</span>
<span class="fc bfc" id="L1506" title="All 2 branches covered.">        if (childNo == 1) {</span>

<span class="fc" id="L1508">          Map&lt;String, Object&gt; hardFormatting = new HashMap&lt;String, Object&gt;();</span>
<span class="fc" id="L1509">          hardFormatting.putAll(frameProps.getShapeHardFormatting());</span>
<span class="fc" id="L1510">          JSONObject drawingProps = (JSONObject) hardFormatting.get(&quot;drawing&quot;);</span>
<span class="fc" id="L1511">          JSONObject imageProps = (JSONObject) hardFormatting.get(&quot;image&quot;);</span>
<span class="pc bpc" id="L1512" title="1 of 2 branches missed.">          if (image.hasAttributeNS(OdfDocumentNamespace.XLINK.getUri(), &quot;href&quot;)) {</span>
            try {
<span class="fc" id="L1514">              String href = image.getAttributeNS(OdfDocumentNamespace.XLINK.getUri(), &quot;href&quot;);</span>
<span class="fc" id="L1515">              imageProps.put(&quot;imageUrl&quot;, href);</span>
              // if there is cropping from the frame, we need to do further calculation based on
              // real graphic size
<span class="fc bfc" id="L1518" title="All 2 branches covered.">              if (imageProps.has(&quot;cropRight&quot;)</span>
<span class="pc bpc" id="L1519" title="2 of 4 branches missed.">                  &amp;&amp; (imageProps.has(&quot;height&quot;) || imageProps.has(&quot;width&quot;))) {</span>
<span class="nc" id="L1520">                JsonOperationProducer.calculateCrops(image, href, imageProps);</span>
              }
<span class="nc" id="L1522">            } catch (JSONException ex) {</span>
<span class="nc" id="L1523">              Logger.getLogger(ChangesFileSaxHandler.class.getName()).log(Level.SEVERE, null, ex);</span>
<span class="fc" id="L1524">            }</span>
          }
<span class="fc bfc" id="L1526" title="All 2 branches covered.">          if (image.hasAttributeNS(OdfDocumentNamespace.XML.getUri(), &quot;id&quot;)) {</span>
            try {
<span class="fc" id="L1528">              drawingProps.put(</span>
<span class="fc" id="L1529">                  &quot;imageXmlId&quot;, image.getAttributeNS(OdfDocumentNamespace.XML.getUri(), &quot;id&quot;));</span>
<span class="nc" id="L1530">            } catch (JSONException ex) {</span>
<span class="nc" id="L1531">              Logger.getLogger(ChangesFileSaxHandler.class.getName()).log(Level.SEVERE, null, ex);</span>
<span class="fc" id="L1532">            }</span>
          }
          // ToDo: Need test document with child element having office:binary-data with base64
          // content

<span class="fc" id="L1537">          DrawFrameElement frameElement = frameProps.getDrawFrameElement();</span>
<span class="fc" id="L1538">          frameElement.markAsComponentRoot(true);</span>
<span class="fc" id="L1539">          mComponentStack.pop();</span>
          //                    mShapePropertiesStack.pollFirst();
<span class="fc" id="L1541">          mComponentStack.push(frameProps);</span>
          //                    mShapePropertiesStack.addFirst(frameProps);
<span class="fc" id="L1543">          frameProps.declareImage();</span>
<span class="fc" id="L1544">          hardFormatting.put(&quot;drawing&quot;, drawingProps);</span>
          //					}else {
          //						drawingProps.put(&quot;viewAlternative&quot;, childNo - 1);
        }

        //				if (!frameProps.hasImageSibling()) {
        //					mComponentDepth++;
        //					frameProps.setFramePosition(updateComponentPosition());
        //					mCurrentComponent = mCurrentComponent.createChildComponent(frameElement);
        //					//			position.set(position.size() - 1, position.get(position.size() - 1) +1);
        //				}
        //				if (childNo == 1) { // DISABLING REPLACEMENT IMAGE FEATURE AS LONG CLIENT DOES NOT
        // SUPPORT IT
        //					 ToDo: Dependencies for frame replacement feature has to be updated in
        // OdfElement.raiseComponentSize() for every Frame child/feature enabled
        //					frameProps.saveShapeProps(frameProps.getShapePosition(), hardFormatting);
        //				}
<span class="fc bfc" id="L1561" title="All 2 branches covered.">      } else if (element instanceof DrawTextBoxElement) {</span>
        //            	element.getAttributeNodeNS(namespaceURI, localName);
        //                Map&lt;String, Object&gt; hardFormatting = null;
        //                if (element instanceof OdfStyleableShapeElement) {
        //                    hardFormatting =
        // mJsonOperationProducer.getHardStyles((OdfStyleableShapeElement) element);
        //                }
        //                JSONObject drawingProps = (JSONObject) hardFormatting.get(&quot;drawing&quot;);
        //            	JSONObject drawingProps = new JSONObject();
<span class="pc bpc" id="L1570" title="1 of 2 branches missed.">        if (!mComponentStack.empty()) {</span>
<span class="fc" id="L1571">          ShapeProperties parentShapeProps = (ShapeProperties) mComponentStack.peek();</span>
<span class="fc" id="L1572">          JSONObject originalDrawingProps =</span>
<span class="fc" id="L1573">              (JSONObject) parentShapeProps.mShapeHardFormatations.get(&quot;drawing&quot;);</span>
<span class="pc bpc" id="L1574" title="1 of 4 branches missed.">          if (originalDrawingProps != null &amp;&amp; !originalDrawingProps.has(&quot;height&quot;)) {</span>
            try {
<span class="fc bfc" id="L1576" title="All 2 branches covered.">              if (!parentShapeProps.mShapeHardFormatations.containsKey(&quot;shape&quot;)) {</span>
<span class="fc" id="L1577">                parentShapeProps.mShapeHardFormatations.put(&quot;shape&quot;, new JSONObject());</span>
              }
<span class="fc" id="L1579">              JSONObject originalShapeProps =</span>
<span class="fc" id="L1580">                  (JSONObject) parentShapeProps.mShapeHardFormatations.get(&quot;shape&quot;);</span>
<span class="fc" id="L1581">              originalShapeProps.put(&quot;autoResizeHeight&quot;, &quot;true&quot;);</span>
<span class="nc" id="L1582">            } catch (JSONException ex) {</span>
<span class="nc" id="L1583">              Logger.getLogger(ChangesFileSaxHandler.class.getName()).log(Level.SEVERE, null, ex);</span>
<span class="fc" id="L1584">            }</span>
          }
        }
      }

      // but within a shape being a frame, the child elements are still of interest (currently only
      // &lt;draw:image&gt; supported)
      //		} else if (!mShapePropertiesStack.isEmpty() &amp;&amp;
      // mShapePropertiesStack.peekLast().mDrawFrameElement != null) {
<span class="fc bfc" id="L1593" title="All 2 branches covered.">      if (Component.isDocumentRoot(uri, localName)</span>
<span class="pc bpc" id="L1594" title="1 of 2 branches missed.">          || Component.isHeaderRoot(uri, localName)</span>
<span class="pc bpc" id="L1595" title="1 of 2 branches missed.">          || Component.isFooterRoot(uri, localName)) {</span>
        // temporary initated here as all the tests are not using the OperationTextDocument
<span class="fc" id="L1597">        mCurrentComponent = new Component(element);</span>
<span class="fc" id="L1598">        mSchemaDoc.setRootComponent(mCurrentComponent);</span>
        // for every header and footer restart counting
<span class="fc bfc" id="L1600" title="All 4 branches covered.">        if (Component.isHeaderRoot(uri, localName) || Component.isFooterRoot(uri, localName)) {</span>
<span class="fc" id="L1601">          mLastComponentPositions.clear();</span>
        } else {
<span class="fc" id="L1603">          mPageArea = PageArea.BODY;</span>
        }
      }
    } else {
<span class="pc bpc" id="L1607" title="1 of 2 branches missed.">      if (element instanceof OdfElement) {</span>
<span class="fc" id="L1608">        element.ignoredComponent(true);</span>
      }
    }

    // add the new element as child &amp; make it the current context node
<span class="fc" id="L1613">    mCurrentNode = mCurrentNode.appendChild(element);</span>
<span class="fc" id="L1614">  }</span>

  @Override
  public void endElement(String uri, String localName, String qName) throws SAXException {
<span class="fc" id="L1618">    flushTextAtEnd(uri, localName, qName);</span>
    // at the end of a table check if it can be flushed
<span class="pc bpc" id="L1620" title="2 of 4 branches missed.">    if (uri != null</span>
        &amp;&amp; localName != null
<span class="fc bfc" id="L1622" title="All 2 branches covered.">        &amp;&amp; localName.equals(TableTableElement.ELEMENT_NAME.getLocalName())</span>
<span class="pc bpc" id="L1623" title="1 of 2 branches missed.">        &amp;&amp; uri.equals(OdfDocumentNamespace.TABLE.getUri())) {</span>
<span class="fc" id="L1624">      endTableSizeEvaluation();</span>
    }
    // office:styles only exist in styles.xml
<span class="fc bfc" id="L1627" title="All 2 branches covered.">    if (qName.equals(&quot;office:styles&quot;)) {</span>
<span class="pc bpc" id="L1628" title="1 of 2 branches missed.">      if (mFileDom instanceof OdfStylesDom) {</span>
<span class="fc" id="L1629">        Integer defaultTabStopWidth = null;</span>
<span class="fc" id="L1630">        JSONObject defaultPageStyles = null;</span>
<span class="fc" id="L1631">        OdfStylesDom stylesDom = (OdfStylesDom) mFileDom;</span>
        // reset the position context used for header/footer
<span class="fc" id="L1633">        mContextName = null;</span>
<span class="fc" id="L1634">        OdfOfficeStyles officeStyles = (OdfOfficeStyles) mCurrentNode;</span>
<span class="pc bpc" id="L1635" title="1 of 2 branches missed.">        if (officeStyles != null) {</span>
          // check if the default hyperlinkstyle do exist
<span class="fc" id="L1637">          mHasHyperlinkTemplateStyle =</span>
<span class="fc bfc" id="L1638" title="All 2 branches covered.">              officeStyles.getStyle(HYERLINK_DEFAULT_STYLE, OdfStyleFamily.Text) != null;</span>
<span class="fc" id="L1639">          final Iterator&lt;OdfStyle&gt; paragraphStyleIter =</span>
<span class="fc" id="L1640">              officeStyles.getStylesForFamily(OdfStyleFamily.Paragraph).iterator();</span>
          // The sort is for testing purpose to receive across different JDK an equal result
<span class="fc" id="L1642">          Integer _defaultTabStopWidth = null;</span>
<span class="fc bfc" id="L1643" title="All 2 branches covered.">          while (paragraphStyleIter.hasNext()) {</span>
            // defaulTableWidth is part of the paragraph default style (optional)
<span class="fc" id="L1645">            _defaultTabStopWidth =</span>
<span class="fc" id="L1646">                mJsonOperationProducer.triggerStyleHierarchyOps(</span>
<span class="fc" id="L1647">                    officeStyles, OdfStyleFamily.Paragraph, paragraphStyleIter.next());</span>
<span class="fc bfc" id="L1648" title="All 2 branches covered.">            if (_defaultTabStopWidth != null) {</span>
<span class="fc" id="L1649">              defaultTabStopWidth = _defaultTabStopWidth;</span>
            }
          }
<span class="fc" id="L1652">          final Iterator&lt;OdfStyle&gt; textStyleIter =</span>
<span class="fc" id="L1653">              officeStyles.getStylesForFamily(OdfStyleFamily.Text).iterator();</span>
<span class="fc bfc" id="L1654" title="All 2 branches covered.">          while (textStyleIter.hasNext()) {</span>
<span class="fc" id="L1655">            mJsonOperationProducer.triggerStyleHierarchyOps(</span>
<span class="fc" id="L1656">                officeStyles, OdfStyleFamily.Text, textStyleIter.next());</span>
          }
<span class="fc" id="L1658">          final Iterator&lt;OdfStyle&gt; graphicStyleIter =</span>
<span class="fc" id="L1659">              officeStyles.getStylesForFamily(OdfStyleFamily.Graphic).iterator();</span>
<span class="fc bfc" id="L1660" title="All 2 branches covered.">          while (graphicStyleIter.hasNext()) {</span>
<span class="fc" id="L1661">            mJsonOperationProducer.triggerStyleHierarchyOps(</span>
<span class="fc" id="L1662">                officeStyles, OdfStyleFamily.Graphic, graphicStyleIter.next());</span>
          }
          // always generate graphic default style
<span class="fc" id="L1665">          mJsonOperationProducer.triggerDefaultStyleOp(</span>
<span class="fc" id="L1666">              OdfStyleFamily.Graphic, officeStyles.getDefaultStyle(OdfStyleFamily.Graphic));</span>

          //    			for(OdfStyle style : officeStyles.getStylesForFamily(OdfStyleFamily.Table)){
          //    				mJsonOperationProducer.triggerStyleHierarchyOps(officeStyles,
          // OdfStyleFamily.Table, style);
          //    			}
          //    			for(OdfStyle style : officeStyles.getStylesForFamily(OdfStyleFamily.TableRow)){
          //    				mJsonOperationProducer.triggerStyleHierarchyOps(officeStyles,
          // OdfStyleFamily.TableRow, style);
          //    			}
          //    			for(OdfStyle style :
          // officeStyles.getStylesForFamily(OdfStyleFamily.TableColumn)){
          //    				mJsonOperationProducer.triggerStyleHierarchyOps(officeStyles,
          // OdfStyleFamily.TableColumn, style);
          //    			}
<span class="pc bpc" id="L1681" title="1 of 2 branches missed.">          for (OdfStyle style : officeStyles.getStylesForFamily(OdfStyleFamily.TableCell)) {</span>
<span class="nc" id="L1682">            mJsonOperationProducer.triggerStyleHierarchyOps(</span>
                officeStyles, OdfStyleFamily.TableCell, style);
            //    				mJsonOperationProducer.triggerStyleHierarchyOps(officeStyles,
            // OdfStyleFamily.TableCell, (OdfStyleBase)
            // officeStyles.getDefaultStyle(OdfStyleFamily.TableCell));
<span class="nc" id="L1687">          }</span>
          //    			for(OdfStyle style : officeStyles.getStylesForFamily(OdfStyleFamily.Section)){
          //    				mJsonOperationProducer.triggerStyleHierarchyOps(officeStyles,
          // OdfStyleFamily.Section, style);
          //    			}
          //    			for(OdfStyle style : officeStyles.getStylesForFamily(OdfStyleFamily.List)){
          //    				mJsonOperationProducer.triggerStyleHierarchyOps(officeStyles,
          // OdfStyleFamily.List, style);
          //    			}
<span class="fc" id="L1696">          final Iterator&lt;OdfTextListStyle&gt; textListStyleIter =</span>
<span class="fc" id="L1697">              officeStyles.getListStyles().iterator();</span>
<span class="fc bfc" id="L1698" title="All 2 branches covered.">          while (textListStyleIter.hasNext()) {</span>
<span class="fc" id="L1699">            mJsonOperationProducer.addListStyle(textListStyleIter.next());</span>
          }

          // maps page properties, but returns the default page properties
<span class="fc" id="L1703">          defaultPageStyles = mJsonOperationProducer.addPageProperties(stylesDom);</span>
          // dispatches default document attributes
<span class="fc" id="L1705">          mJsonOperationProducer.addDocumentProperties(</span>
              stylesDom, defaultTabStopWidth, defaultPageStyles);
<span class="fc" id="L1707">        } else {</span>
<span class="nc" id="L1708">          mJsonOperationProducer.addDocumentProperties(stylesDom, null, null);</span>
        }
      }
    }
    // if we remove the current element, the current node shall not be changed in the end
<span class="fc" id="L1713">    boolean selectionNormalization = false;</span>
    // SPECIAL HANDLING FOR DESCRIPTION OF SHAPES: draw:frame as the shape is one of the children,
    // e.g a draw:image child
<span class="fc bfc" id="L1716" title="All 2 branches covered.">    if (!checkEndOfBlockedSubTree(</span>
        uri, localName) /*&amp;&amp; !(mContextName != null &amp;&amp; localName.equals(&quot;annotation-end&quot;))*/) {
<span class="fc" id="L1718">      boolean isImageComponent = false;</span>
<span class="pc bpc" id="L1719" title="1 of 2 branches missed.">      if ((uri != null</span>
<span class="fc bfc" id="L1720" title="All 2 branches covered.">              &amp;&amp; uri.equals(DrawFrameElement.ELEMENT_NAME.getUri())</span>
<span class="fc bfc" id="L1721" title="All 2 branches covered.">              &amp;&amp; localName.equals(DrawFrameElement.ELEMENT_NAME.getLocalName())</span>
<span class="fc bfc" id="L1722" title="All 2 branches covered.">          || Component.isShapeElement(uri, localName))) {</span>
<span class="pc bpc" id="L1723" title="1 of 2 branches missed.">        if (!mComponentStack.empty()) {</span>
<span class="fc" id="L1724">          ShapeProperties shapeProps = (ShapeProperties) mComponentStack.pop();</span>
<span class="fc" id="L1725">          mComponentDepth--;</span>
          // Check for description of shape/frame about to be closed
          //                ShapeProperties shapeProps = mShapePropertiesStack.removeLast();
<span class="fc" id="L1728">          isImageComponent = shapeProps.hasImageSibling();</span>
<span class="fc" id="L1729">          NodeList descList =</span>
<span class="fc" id="L1730">              mCurrentComponent.mRootElement.getElementsByTagNameNS(</span>
<span class="fc" id="L1731">                  OdfDocumentNamespace.SVG.getUri(), SvgDescElement.ELEMENT_NAME.getLocalName());</span>
<span class="fc" id="L1732">          String description = null;</span>
<span class="fc bfc" id="L1733" title="All 2 branches covered.">          if (descList.getLength() &gt; 0) {</span>
<span class="fc" id="L1734">            SvgDescElement desc = (SvgDescElement) descList.item(0);</span>
<span class="fc" id="L1735">            Node descText = desc.getFirstChild();</span>
<span class="pc bpc" id="L1736" title="1 of 4 branches missed.">            if (descText != null &amp;&amp; descText instanceof Text) {</span>
<span class="fc" id="L1737">              description = ((Text) descText).getTextContent();</span>
            }
          }
          // it is root shape if the parent office:text
<span class="fc" id="L1741">          shapeProps.createShapeOperation(</span>
              this,
              mComponentStack,
              description,
<span class="fc bfc" id="L1745" title="All 2 branches covered.">              isImageComponent</span>
<span class="fc" id="L1746">                  ? ShapeType.ImageShape</span>
<span class="fc bfc" id="L1747" title="All 2 branches covered.">                  : shapeProps.isGroupShape() ? ShapeType.GroupShape : ShapeType.NormalShape,</span>
              mContextName);
<span class="fc bfc" id="L1749" title="All 2 branches covered.">          if (shapeProps.isGroupShape()) {</span>
<span class="fc" id="L1750">            mCurrentNode.setUserData(</span>
                &quot;groupWidth&quot;,
                new Integer(
<span class="fc" id="L1753">                    shapeProps.mHoriOffsetMax</span>
<span class="pc bpc" id="L1754" title="1 of 2 branches missed.">                        - (shapeProps.mHoriOffsetMin == null ? 0 : shapeProps.mHoriOffsetMin)),</span>
                null);
<span class="fc" id="L1756">            mCurrentNode.setUserData(</span>
                &quot;groupHeight&quot;,
                new Integer(
<span class="fc" id="L1759">                    shapeProps.mVertOffsetMax</span>
<span class="pc bpc" id="L1760" title="1 of 2 branches missed.">                        - (shapeProps.mVertOffsetMin == null ? 0 : shapeProps.mVertOffsetMin)),</span>
                null);
          }
          // flush the inner operations of the shape
<span class="fc" id="L1764">          Iterator&lt;CachedOperation&gt; opIter = shapeProps.iterator();</span>
<span class="fc bfc" id="L1765" title="All 2 branches covered.">          while (opIter.hasNext()) {</span>
<span class="fc" id="L1766">            CachedOperation op = opIter.next();</span>
<span class="fc" id="L1767">            cacheOperation(</span>
                true,
                op.mComponentType,
                op.mStart,
                false,
                op.mHardFormattingProperties,
                op.mComponentProperties);
<span class="fc" id="L1774">          }</span>
<span class="fc" id="L1775">          mCurrentComponent = mCurrentComponent.getParent();</span>
<span class="fc" id="L1776">        }</span>

        //			} else if (Component.isCoveredComponentRoot(uri, localName)) { // adjust counting for
        // table cells without numbering
        //				//ToDO: Instead to count the covered someone should count the spanning (BUT this is
        // against OOXML cell numbering!)
        //				mComponentDepth--;
<span class="fc bfc" id="L1783" title="All 2 branches covered.">      } else if (isSpaceElement(uri, localName)) {</span>
<span class="fc" id="L1784">        mComponentDepth--;</span>
<span class="fc" id="L1785">        mCurrentComponent = mCurrentComponent.getParent();</span>
        //		} else if (uri != null &amp;&amp; uri.equals(DrawImageElement.ELEMENT_NAME.getUri()) &amp;&amp;
        // localName.equals(DrawImageElement.ELEMENT_NAME.getLocalName())) {
        //			mFramePropertiesStack.getFirst().decrementChildNumber();
<span class="pc bpc" id="L1789" title="1 of 4 branches missed.">      } else if (uri != null &amp;&amp; Component.isComponentRoot(uri, localName)) {</span>
        //                if (Component.isTextComponentRoot(uri, localName) &amp;&amp;
        // mWhitespaceStatusStack.size() &gt; 0 &amp;&amp;
        // mWhitespaceStatusStack.getLast().mIsParagraphIgnored) {
        /* no ignored paragraphs anymore
        if (Component.isTextComponentRoot(uri, localName) &amp;&amp; mWhitespaceStatusStack.size() &gt; 0 &amp;&amp; mWhitespaceStatusStack.getLast().mIsParagraphIgnored) {) {
               // do nothing for a ignored paragraph
               mWhitespaceStatusStack.removeLast();
               // SPECIAL HANDLING FOR IMAGE: draw:image (not a component root T- replacement for draw:frame)
           } else */
<span class="pc bpc" id="L1799" title="1 of 2 branches missed.">        if (localName.equals(DrawFrameElement.ELEMENT_NAME.getLocalName())</span>
<span class="pc bnc" id="L1800" title="All 4 branches missed.">                &amp;&amp; uri.equals(DrawFrameElement.ELEMENT_NAME.getUri())</span>
                &amp;&amp; isImageComponent
<span class="pc bpc" id="L1802" title="1 of 2 branches missed.">            || !(localName.equals(DrawFrameElement.ELEMENT_NAME.getLocalName())</span>
<span class="nc bnc" id="L1803" title="All 2 branches missed.">                &amp;&amp; uri.equals(DrawFrameElement.ELEMENT_NAME.getUri()))) {</span>
          // if the current component is a text container flush spans
<span class="fc bfc" id="L1805" title="All 2 branches covered.">          if (Component.isTextComponentRoot(mCurrentNode)) {</span>
<span class="fc" id="L1806">            Collection&lt;TextSelection&gt; selections =</span>
<span class="fc" id="L1807">                ((TextParagraphElementBase) mCurrentNode).getTextSelections();</span>
<span class="fc bfc" id="L1808" title="All 2 branches covered.">            if (selections != null) {</span>
<span class="fc bfc" id="L1809" title="All 2 branches covered.">              for (TextSelection s : selections) {</span>
<span class="fc" id="L1810">                OdfStylableElement selectionElement = (OdfStylableElement) s.getSelectionElement();</span>
<span class="fc" id="L1811">                Map&lt;String, Object&gt; hardFormatting =</span>
<span class="fc" id="L1812">                    mJsonOperationProducer.getHardStyles(selectionElement);</span>
<span class="fc" id="L1813">                String styleId = null;</span>
<span class="fc" id="L1814">                OdfStyle templateStyle = selectionElement.getDocumentStyle();</span>
<span class="fc bfc" id="L1815" title="All 2 branches covered.">                if (templateStyle != null) {</span>
<span class="fc" id="L1816">                  styleId = templateStyle.getStyleNameAttribute();</span>
                }
<span class="fc bfc" id="L1818" title="All 4 branches covered.">                if (s.hasUrl() || styleId != null) {</span>
                  try {
                    JSONObject charProps;
<span class="fc bfc" id="L1821" title="All 2 branches covered.">                    if (hardFormatting == null) {</span>
                      // if there are absolute styles, but not the main property set, where the
                      // templateStyleId should be placed in
<span class="pc bpc" id="L1824" title="1 of 2 branches missed.">                      if (hardFormatting == null) {</span>
<span class="fc" id="L1825">                        hardFormatting = new HashMap&lt;String, Object&gt;();</span>
                      }
                    }
<span class="fc bfc" id="L1828" title="All 2 branches covered.">                    if (s.hasUrl()) {</span>
<span class="fc bfc" id="L1829" title="All 2 branches covered.">                      if (!hardFormatting.containsKey(&quot;character&quot;)) {</span>
<span class="fc" id="L1830">                        charProps = new JSONObject();</span>
<span class="fc" id="L1831">                        hardFormatting.put(&quot;character&quot;, charProps);</span>
                      } else {
<span class="fc" id="L1833">                        charProps = (JSONObject) hardFormatting.get(&quot;character&quot;);</span>
                      }
<span class="fc" id="L1835">                      charProps.put(&quot;url&quot;, s.getURL());</span>
                    }
<span class="pc bpc" id="L1837" title="1 of 4 branches missed.">                    if (styleId != null &amp;&amp; !styleId.isEmpty()) {</span>
<span class="fc" id="L1838">                      hardFormatting.put(OPK_STYLE_ID, styleId);</span>
                    } else {
                      // add the implicit by LO/AOO used hyperlink style
<span class="fc bfc" id="L1841" title="All 2 branches covered.">                      if (mHasHyperlinkTemplateStyle) {</span>
<span class="fc" id="L1842">                        hardFormatting.put(OPK_STYLE_ID, HYERLINK_DEFAULT_STYLE);</span>
                      }
                    }
<span class="nc" id="L1845">                  } catch (JSONException ex) {</span>
<span class="nc" id="L1846">                    Logger.getLogger(ChangesFileSaxHandler.class.getName())</span>
<span class="nc" id="L1847">                        .log(Level.SEVERE, null, ex);</span>
<span class="fc" id="L1848">                  }</span>
                }
<span class="fc bfc" id="L1850" title="All 2 branches covered.">                if (hardFormatting != null) {</span>
                  //                                    if (mWithinTable) {
<span class="fc" id="L1852">                  cacheOperation(</span>
                      false,
                      OperationConstants.ATTRIBUTES,
<span class="fc" id="L1855">                      s.getStartPosition(),</span>
                      false,
                      hardFormatting,
<span class="fc" id="L1858">                      s.getEndPosition(),</span>
                      mContextName);
                }
<span class="fc" id="L1861">              }</span>
            }
            //					// in this case check if the closing descendent (this element)
            //					// had any none whitespace text and apply if necessary the change
            //					// remove the current whitespace properties from the stack
            //					int depth = mWhitespaceStatusStack.size();
            //					boolean childHasWhiteSpace = true;
            //					boolean parentHasOnlyWhiteSpace;
            // if there is a parent text container
<span class="pc bpc" id="L1870" title="1 of 2 branches missed.">            if (mWhitespaceStatusStack.size() &gt; 0) {</span>
<span class="fc" id="L1871">              mWhitespaceStatusStack.removeLast();</span>
              // BEFORE WE DID NOT ALLOWED TO FOLLOWING PARAGRAPHS
              //						// see if the child only had whitespaces
              //						childHasWhiteSpace = mWhitespaceStatusStack.getLast().hasOnlyWhiteSpace();
              //						// switch to parent
              //						mWhitespaceStatusStack.pop();
              //						// see if the parent had only whitespaces
              //						WhitespaceStatus parentWhiteSpaceStatus = mWhitespaceStatusStack.getLast();
              //						parentHasOnlyWhiteSpace = parentWhiteSpaceStatus.hasOnlyWhiteSpace();
              //						// if the parent had only whitespaces, but not the child
              //						if (parentHasOnlyWhiteSpace &amp;&amp; !childHasWhiteSpace) {
              //							// remove the only whitespace modus from the parent
              //							parentWhiteSpaceStatus.setOnlyWhiteSpace(childHasWhiteSpace);
              //						}
              //					} else {
              //						// otherwise just end the state collection of this paragraph/heading
              //						mWhitespaceStatusStack.pop();
            }
          }
          // removing the last in the list of positions, when a component is closed
<span class="fc bfc" id="L1891" title="All 2 branches covered.">          if (localName.equals(&quot;annotation&quot;)) {</span>
<span class="fc" id="L1892">            CommentComponent commProps = (CommentComponent) mComponentStack.pop();</span>
<span class="pc bpc" id="L1893" title="1 of 2 branches missed.">            if (!commProps.isInHeaderFooter()) {</span>
<span class="fc" id="L1894">              String id = COMMENT_PREFIX;</span>
<span class="fc" id="L1895">              id += commProps.getCommentName();</span>
<span class="fc" id="L1896">              cacheOperation(</span>
                  false,
                  OperationConstants.COMMENT,
<span class="fc" id="L1899">                  commProps.getComponentPosition(),</span>
                  false,
                  null,
                  id,
<span class="fc" id="L1903">                  commProps.getAuthor(),</span>
<span class="fc" id="L1904">                  commProps.getDate(),</span>
                  mContextName);
<span class="fc" id="L1906">              int parentPosSize = commProps.getComponentPosition().size();</span>
<span class="fc bfc" id="L1907" title="All 2 branches covered.">              for (CachedOperation op : commProps) {</span>
                // TODO: add id as target, remove comments own position from op.mStart;
<span class="fc" id="L1909">                CachedOperation newOp = op.clone();</span>
<span class="fc bfc" id="L1910" title="All 2 branches covered.">                for (int r = 0; r &lt; parentPosSize; ++r) {</span>
<span class="fc" id="L1911">                  newOp.mStart.remove(0);</span>
                }

<span class="fc" id="L1914">                ArrayList&lt;Object&gt; componentProperties = new ArrayList&lt;Object&gt;();</span>
<span class="fc" id="L1915">                int propIndex = 0;</span>
<span class="fc bfc" id="L1916" title="All 4 branches covered.">                while (newOp.mComponentProperties.length &gt; propIndex</span>
                    &amp;&amp; newOp.mComponentProperties[propIndex] != null) {
<span class="fc bfc" id="L1918" title="All 2 branches covered.">                  if (propIndex == 0</span>
<span class="fc bfc" id="L1919" title="All 2 branches covered.">                      &amp;&amp; newOp.mComponentType.equals(OperationConstants.ATTRIBUTES)) {</span>
                    @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L1921">                    List&lt;Integer&gt; endArray = (List&lt;Integer&gt;) newOp.mComponentProperties[propIndex];</span>
<span class="fc bfc" id="L1922" title="All 2 branches covered.">                    for (int r = 0; r &lt; parentPosSize; ++r) {</span>
<span class="fc" id="L1923">                      endArray.remove(0);</span>
                    }
<span class="fc" id="L1925">                    componentProperties.add(endArray);</span>
<span class="fc bfc" id="L1926" title="All 2 branches covered.">                  } else if (mContextName == null</span>
<span class="fc bfc" id="L1927" title="All 2 branches covered.">                      || !newOp.mComponentProperties[propIndex].equals(mContextName)) {</span>
<span class="fc" id="L1928">                    componentProperties.add(newOp.mComponentProperties[propIndex]);</span>
                  }
<span class="fc" id="L1930">                  ++propIndex;</span>
                }
<span class="fc" id="L1932">                componentProperties.add(id);</span>
<span class="fc" id="L1933">                componentProperties.add(null);</span>
<span class="fc" id="L1934">                cacheOperation(</span>
                    false,
                    newOp.mComponentType,
                    newOp.mStart,
                    true,
                    newOp.mHardFormattingProperties,
<span class="fc" id="L1940">                    componentProperties.toArray());</span>
<span class="fc" id="L1941">              }</span>
            }
            //                    } else if (localName.equals(&quot;annotation-end&quot;)){ //no action
            // required
          }
<span class="fc bfc" id="L1946" title="All 2 branches covered.">          if (mCurrentComponent.hasRepeated()) {</span>
            // if it is a cell or row not in spreadsheets all operations back from addCell/addRows
            // need to be repeated with incremented positions (TODO: needs to be recursive! )
<span class="fc" id="L1949">            boolean isCell = localName.equals(&quot;table-cell&quot;);</span>
<span class="fc" id="L1950">            boolean isRow = localName.equals(&quot;table-row&quot;);</span>
<span class="pc bpc" id="L1951" title="1 of 4 branches missed.">            if (isRow || isCell) {</span>
<span class="fc" id="L1952">              CachedTable currentTable = (CachedTable) mComponentStack.peek();</span>
<span class="fc" id="L1953">              int opSize = currentTable.size();</span>
<span class="fc" id="L1954">              int pos = 0;</span>
<span class="pc bpc" id="L1955" title="1 of 2 branches missed.">              for (pos = opSize - 1; pos &gt;= 0; --pos) {</span>
<span class="fc" id="L1956">                CachedOperation op = currentTable.get(pos);</span>
<span class="fc bfc" id="L1957" title="All 2 branches covered.">                if (op.mComponentType.equals(</span>
<span class="fc bfc" id="L1958" title="All 2 branches covered.">                    isRow ? OperationConstants.ROWS : OperationConstants.CELLS)) {</span>
<span class="fc" id="L1959">                  break;</span>
                }
              }
              // now we have a start index - add all ops from pos to opSize- 1 again
              // repetition-times with modified position
<span class="pc bpc" id="L1964" title="1 of 2 branches missed.">              if (pos &gt; 0) {</span>
<span class="fc" id="L1965">                CachedOperation cellInsertOp = currentTable.get(pos);</span>
<span class="fc" id="L1966">                int incrementPos = cellInsertOp.mStart.size() - 1;</span>
<span class="fc bfc" id="L1967" title="All 2 branches covered.">                int repetition = (Integer) cellInsertOp.mComponentProperties[isRow ? 0 : 1];</span>
<span class="fc bfc" id="L1968" title="All 2 branches covered.">                for (int rep = 0; rep &lt; repetition - 1; ++rep) {</span>
<span class="fc bfc" id="L1969" title="All 2 branches covered.">                  for (int opPos = pos; opPos &lt; opSize; ++opPos) {</span>
<span class="fc" id="L1970">                    CachedOperation newOp = currentTable.get(opPos).clone();</span>
<span class="pc bpc" id="L1971" title="1 of 2 branches missed.">                    if (newOp.mStart != null) {</span>
<span class="fc" id="L1972">                      int oldIndex = newOp.mStart.get(incrementPos);</span>
<span class="fc" id="L1973">                      newOp.mStart.set(incrementPos, oldIndex + rep + 1);</span>
                    }
<span class="fc" id="L1975">                    cacheOperation(</span>
                        false,
                        newOp.mComponentType,
                        newOp.mStart,
                        false,
                        newOp.mHardFormattingProperties,
                        newOp.mComponentProperties);
                  }
                }
              }
            }
<span class="fc" id="L1986">            mLastComponentPositions.set(</span>
                mComponentDepth,
<span class="fc" id="L1988">                mLastComponentPositions.get(mComponentDepth) + mCurrentComponent.repetition() - 1);</span>
          }
<span class="fc" id="L1990">          mComponentDepth--;</span>
<span class="fc" id="L1991">          mCurrentComponent = mCurrentComponent.getParent();</span>
        }
      } // if text delimiter - addChild text
<span class="fc bfc" id="L1994" title="All 2 branches covered.">      else if (Component.isTextSelection(mCurrentNode)) {</span>
        // dropping the last (most inner) selection from the stack
<span class="fc" id="L1996">        TextSelection textSelection = mTextSelectionStack.pollLast();</span>
<span class="fc bfc" id="L1997" title="All 2 branches covered.">        if (textSelection != null) {</span>
<span class="fc" id="L1998">          textSelection.setEndPosition(getTextPosition());</span>
<span class="fc" id="L1999">          OdfElement root = ((OdfElement) mCurrentNode).getComponentRoot();</span>
<span class="pc bpc" id="L2000" title="1 of 2 branches missed.">          if (Component.isTextComponentRoot(root)) {</span>
            // sometimes when spans share the same text area, they are condensed to one. The
            // remaining one is being returned, or in case of an empty element the parent
<span class="fc" id="L2003">            mCurrentNode = ((TextContainingElement) root).appendTextSelection(textSelection);</span>
            // selectionNormalization might delete an element in this case the change of the current
            // node would be an error!
<span class="fc" id="L2006">            selectionNormalization = true;</span>
          }
        }
<span class="fc bfc" id="L2009" title="All 4 branches covered.">      } else if (uri.equals(OdfDocumentNamespace.TEXT.getUri()) &amp;&amp; localName.equals(&quot;list-item&quot;)) {</span>
<span class="fc" id="L2010">        mListStyleStack.getLast().overrideListStyle(null);</span>
<span class="fc bfc" id="L2011" title="All 4 branches covered.">      } else if (uri.equals(OdfDocumentNamespace.TEXT.getUri()) &amp;&amp; localName.equals(&quot;list&quot;)) {</span>
        // POP UP NEW LIST STYLE
<span class="fc" id="L2013">        mListStyleStack.removeLast();</span>
<span class="fc bfc" id="L2014" title="All 2 branches covered.">      } else if (localName.equals(&quot;creator&quot;)) {</span>
<span class="pc bpc" id="L2015" title="1 of 2 branches missed.">        CachedComponent commProps = mComponentStack.isEmpty() ? null : mComponentStack.peek();</span>
<span class="pc bpc" id="L2016" title="2 of 4 branches missed.">        if (commProps != null &amp;&amp; commProps instanceof CommentComponent) {</span>
<span class="fc" id="L2017">          ((CommentComponent) commProps).setAuthor(mCurrentNode.getTextContent());</span>
        }
<span class="fc bfc" id="L2019" title="All 2 branches covered.">      } else if (localName.equals(&quot;date&quot;)) {</span>
<span class="pc bpc" id="L2020" title="1 of 2 branches missed.">        CachedComponent commProps = mComponentStack.isEmpty() ? null : mComponentStack.peek();</span>
<span class="pc bpc" id="L2021" title="2 of 4 branches missed.">        if (commProps != null &amp;&amp; commProps instanceof CommentComponent) {</span>
<span class="fc" id="L2022">          ((CommentComponent) commProps).setDate(mCurrentNode.getTextContent());</span>
        }
      }
    }
    // selectionNormalization might delete an element in this case the change of the current node
    // would be an error!
<span class="pc bpc" id="L2028" title="1 of 4 branches missed.">    if (mCurrentNode != null &amp;&amp; !selectionNormalization) {</span>
      // pop to the parent node
<span class="fc" id="L2030">      mCurrentNode = mCurrentNode.getParentNode();</span>
    }
<span class="fc" id="L2032">  }</span>

  private void addAttributes(Element element, Attributes attributes) {
    String attrQname;
    String attrURL;
    OdfAttribute attr;
<span class="fc bfc" id="L2038" title="All 2 branches covered.">    for (int i = 0; i &lt; attributes.getLength(); i++) {</span>
<span class="fc" id="L2039">      attrURL = attributes.getURI(i);</span>
<span class="fc" id="L2040">      attrQname = attributes.getQName(i);</span>
      // if no namespace exists
<span class="pc bpc" id="L2042" title="1 of 4 branches missed.">      if (attrURL.equals(Constants.EMPTY_STRING) || attrQname.equals(Constants.EMPTY_STRING)) {</span>
        // create attribute without prefix
<span class="fc" id="L2044">        attr = mFileDom.createAttribute(attributes.getLocalName(i));</span>
      } else {
<span class="fc bfc" id="L2046" title="All 2 branches covered.">        if (attrQname.startsWith(&quot;xmlns:&quot;)) {</span>
          // in case of xmlns prefix we have to create a new OdfNamespace
<span class="fc" id="L2048">          OdfNamespace namespace =</span>
<span class="fc" id="L2049">              mFileDom.setNamespace(attributes.getLocalName(i), attributes.getValue(i));</span>
          // if the file Dom is already associated to parsed XML addChild the new namespace to the
          // root element
<span class="fc" id="L2052">          Element root = mFileDom.getRootElement();</span>
<span class="fc bfc" id="L2053" title="All 2 branches covered.">          if (root == null) {</span>
<span class="fc" id="L2054">            root = element;</span>
          }
<span class="fc" id="L2056">          root.setAttributeNS(</span>
              &quot;http://www.w3.org/2000/xmlns/&quot;,
<span class="fc" id="L2058">              &quot;xmlns:&quot; + namespace.getPrefix(),</span>
<span class="fc" id="L2059">              namespace.getUri());</span>
        }
        // create all attributes, even namespace attributes
<span class="fc" id="L2062">        attr = mFileDom.createAttributeNS(attrURL, attrQname);</span>
      }

      // namespace attributes will not be created and return null
<span class="pc bpc" id="L2066" title="1 of 2 branches missed.">      if (attr != null) {</span>
<span class="fc" id="L2067">        element.setAttributeNodeNS(attr);</span>
        try {
          // set Value in the attribute to allow validation in the attribute
<span class="fc" id="L2070">          attr.setValue(attributes.getValue(i));</span>
        } // if we detect an attribute with invalid value: remove attribute node
<span class="nc" id="L2072">        catch (IllegalArgumentException e) {</span>
<span class="nc" id="L2073">          ErrorHandler errorHandler = mFileDom.getDocument().getPackage().getErrorHandler();</span>
<span class="nc bnc" id="L2074" title="All 2 branches missed.">          if (errorHandler != null) {</span>
            try {
<span class="nc" id="L2076">              errorHandler.error(</span>
                  new OdfValidationException(
                      OdfSchemaConstraint.DOCUMENT_XML_INVALID_ATTRIBUTE_VALUE,
<span class="nc" id="L2079">                      attr.getValue(),</span>
<span class="nc" id="L2080">                      attr.getPrefix() + &quot;:&quot; + attr.getLocalName()));</span>
<span class="nc" id="L2081">            } catch (SAXException ex) {</span>
<span class="nc" id="L2082">              Logger.getLogger(StyleStyleElement.class.getName()).log(Level.SEVERE, null, ex);</span>
<span class="nc" id="L2083">            }</span>
          } else {
<span class="nc" id="L2085">            LOG.severe(</span>
                &quot;ERROR / EXCEPTION DURING XML PARSING: INVALID ATTRIBUTE: '&quot;
<span class="nc" id="L2087">                    + attr.getPrefix()</span>
                    + &quot;:&quot;
<span class="nc" id="L2089">                    + attr.getLocalName()</span>
                    + &quot;' with value '&quot;
<span class="nc" id="L2091">                    + attr.getValue()</span>
                    + &quot;'!&quot;);
          }
<span class="nc" id="L2094">          element.removeAttributeNode(attr);</span>
<span class="fc" id="L2095">        }</span>
      }
    }
<span class="fc" id="L2098">  }</span>

  private void flushTextAtStart(String uri, String localName, String qName) {
<span class="fc" id="L2101">    flushText(uri, localName, qName, false);</span>
<span class="fc" id="L2102">  }</span>

  private void flushTextAtEnd(String uri, String localName, String qName) {
<span class="fc" id="L2105">    flushText(uri, localName, qName, true);</span>
<span class="fc" id="L2106">  }</span>

  /**
   * Consumers shall collapse white space characters that occur in
   *
   * &lt;ul&gt;
   *   &lt;li&gt;a &lt;text:p&gt; or &lt;text:h&gt; element (so called paragraph elements), and
   *   &lt;li&gt;in their descendant elements, if the OpenDocument schema permits the inclusion of
   *       character data for the element itself and all its ancestor elements up to the paragraph
   *       element.
   * &lt;/ul&gt;
   *
   * Collapsing white space characters is defined by the following algorithm: 1)The following
   * [UNICODE] characters are replaced by a &quot; &quot; (U+0020, SPACE) character: \ue570HORIZONTAL
   * TABULATION (U+0009) \ue570CARRIAGE RETURN (U+000D) \ue570LINE FEED (U+000A) 2)The character
   * data of the paragraph element and of all descendant elements for which the OpenDocument schema
   * permits the inclusion of character data for the element itself and all its ancestor elements up
   * to the paragraph element, is concatenated in document order. 3)Leading &quot; &quot; (U+0020, SPACE)
   * characters at the start of the resulting text and trailing SPACE characters at the end of the
   * resulting text are removed. 4)Sequences of &quot; &quot; (U+0020, SPACE) characters are replaced by a
   * single &quot; &quot; (U+0020, SPACE) character.
   */
  private void flushText(String uri, String localName, String qName, boolean isEndOfElement) {
    // check if there is was text found to be added to the element
<span class="fc bfc" id="L2130" title="All 2 branches covered.">    if (mCharsForElement.length() &gt; 0) {</span>
      // every text will be kept from the XML file (e.g. indent)
<span class="fc" id="L2132">      String newString = mCharsForElement.toString();</span>
<span class="fc" id="L2133">      mCharsForElement.setLength(0);</span>
<span class="fc" id="L2134">      Text text = mFileDom.createTextNode(newString);</span>
<span class="fc bfc" id="L2135" title="All 4 branches covered.">      if (isEndOfElement &amp;&amp; Component.isField(uri, localName)) {</span>
<span class="fc" id="L2136">        TextSelection textSelection = mTextSelectionStack.pollLast();</span>
<span class="fc bfc" id="L2137" title="All 2 branches covered.">        if (!isBlockedSubTree()) {</span>
          // Currently only check-box have an UTF-8 square as replacementText
<span class="fc" id="L2139">          TextFieldSelection textFieldSelection = (TextFieldSelection) textSelection;</span>
<span class="fc" id="L2140">          String replacementText = textFieldSelection.getReplacementText();</span>
<span class="fc" id="L2141">          Map&lt;String, Object&gt; attrMap = textFieldSelection.getAttributes();</span>

<span class="fc" id="L2143">          cacheOperation(</span>
              false,
              OperationConstants.FIELD,
<span class="fc" id="L2146">              textSelection.getStartPosition(),</span>
              false,
              null,
              localName,
<span class="fc bfc" id="L2150" title="All 2 branches covered.">              replacementText != null ? replacementText : newString,</span>
              attrMap,
              mContextName);
        }
<span class="fc" id="L2154">        mCurrentNode.appendChild(text);</span>
<span class="fc" id="L2155">      } else {</span>
        // if the text is within a text aware component
<span class="pc bpc" id="L2157" title="1 of 2 branches missed.">        if (mCurrentNode instanceof OdfElement) {</span>
          // ToDo: Uncertain what with text should happen that is not within a text component?
          // Neglectable by
          //                    if ((Component.isTextComponentRoot(mCurrentNode) ||
          // Component.isTextComponentRoot(((OdfElement) mCurrentNode).getComponentRoot())) &amp;&amp;
          // !isBlockedSubTree() &amp;&amp; mWhitespaceStatusStack.size() &gt; 0 &amp;&amp;
          // !mWhitespaceStatusStack.getLast().isParagraphIgnored() &amp;&amp; !(mCurrentNode instanceof
          // TextNoteCitationElement)) {
<span class="fc bfc" id="L2165" title="All 2 branches covered.">          if ((Component.isTextComponentRoot(mCurrentNode)</span>
<span class="fc bfc" id="L2166" title="All 2 branches covered.">                  || Component.isTextComponentRoot(((OdfElement) mCurrentNode).getComponentRoot()))</span>
<span class="fc bfc" id="L2167" title="All 2 branches covered.">              &amp;&amp; !isBlockedSubTree()</span>
<span class="pc bpc" id="L2168" title="2 of 4 branches missed.">              &amp;&amp; mWhitespaceStatusStack.size() &gt; 0</span>
              &amp;&amp; !(mCurrentNode instanceof TextNoteCitationElement)) {
<span class="fc" id="L2170">            mComponentDepth++;</span>
<span class="pc bpc" id="L2171" title="1 of 2 branches missed.">            if (mIsCharsBeginning) {</span>
<span class="fc" id="L2172">              mCharsStartPosition = updateTextPosition();</span>
<span class="fc" id="L2173">              mIsCharsBeginning = false;</span>
            }
<span class="fc" id="L2175">            mComponentDepth--;</span>
            // The new charPosition adds the text lenght, but inserted will be without
            // 1) insertion
<span class="fc" id="L2178">            addText(/*mCachedTableOps, */ newString);</span>
            // the following would cumulate the text of a paragraph to a single large string
            // mCharsForOperation.append(newString);

            // muss ich rekursiv die gr\u00f6sse nach oben reichen? f\u00fcr jeden none component
            // descendant? K\u00f6nnte ich in OdfElement implemenentieren!
            // \u00fcberschreibe alle addChild/delete Funktionalit\u00e4t!
            // Merge/split/delete Text Funktionalit\u00e4t f\u00fcr alle ELEMENTE? Komponenten
            // m\u00fcssen mit einbezogen werden! Reuse of Recursion -- ACTION KLASSE.operate()
            // aufruf!?!?
            //					OdfElement element = (OdfElement) mCurrentNode;
            //					element.appendChild(text);
          }
<span class="fc bfc" id="L2191" title="All 2 branches covered.">          if (isSpaceElement(mCurrentNode)) {</span>
<span class="fc" id="L2192">            mCurrentNode.getParentNode().appendChild(text);</span>
          } else {
<span class="fc" id="L2194">            mCurrentNode.appendChild(text);</span>
          }
        }
      }
<span class="fc" id="L2198">    } else {</span>
<span class="fc bfc" id="L2199" title="All 4 branches covered.">      if (isEndOfElement &amp;&amp; Component.isField(uri, localName)) {</span>
<span class="fc" id="L2200">        TextSelection textSelection = mTextSelectionStack.pollLast();</span>
<span class="pc bpc" id="L2201" title="1 of 2 branches missed.">        if (!isBlockedSubTree()) {</span>
          // Currently only check-box have an UTF-8 square as replacementText
<span class="fc" id="L2203">          TextFieldSelection textFieldSelection = (TextFieldSelection) textSelection;</span>
<span class="fc" id="L2204">          String replacementText = textFieldSelection.getReplacementText();</span>
<span class="fc" id="L2205">          Map&lt;String, Object&gt; attrMap = textFieldSelection.getAttributes();</span>
<span class="fc bfc" id="L2206" title="All 2 branches covered.">          if (replacementText == null) {</span>
<span class="fc" id="L2207">            replacementText = new String();</span>
          }
<span class="fc" id="L2209">          cacheOperation(</span>
              false,
              OperationConstants.FIELD,
<span class="fc" id="L2212">              textSelection.getStartPosition(),</span>
              false,
              null,
              localName,
              replacementText,
              attrMap,
              mContextName);
        }
      }
    }
<span class="pc bpc" id="L2222" title="1 of 2 branches missed.">    if (mCharsForOperation.length() &gt; 0</span>
<span class="nc bnc" id="L2223" title="All 2 branches missed.">        &amp;&amp; Component.isComponentRoot(uri, localName)</span>
<span class="nc bnc" id="L2224" title="All 2 branches missed.">        &amp;&amp; !isSpaceElement(uri, localName)) {</span>
<span class="nc" id="L2225">      addText(/*mCachedTableOps, */ mCharsForOperation);</span>
    }
<span class="fc" id="L2227">  }</span>

  private void addText(CharSequence newText) {
<span class="fc" id="L2230">    cacheOperation(</span>
        false,
        OperationConstants.TEXT,
        mCharsStartPosition,
        false,
        null,
<span class="fc" id="L2236">        newText.toString(),</span>
        mContextName);
<span class="fc" id="L2238">    mCharsForOperation.setLength(0);</span>
<span class="fc" id="L2239">    mIsCharsBeginning = true;</span>
<span class="fc" id="L2240">  }</span>

  static boolean isSpaceElement(Node node) {
<span class="fc" id="L2243">    return node instanceof TextSElement;</span>
  }

  static boolean isSpaceElement(String uri, String localName) {
<span class="pc bpc" id="L2247" title="1 of 2 branches missed.">    return uri != null</span>
<span class="fc bfc" id="L2248" title="All 2 branches covered.">        &amp;&amp; uri.equals(TextSElement.ELEMENT_NAME.getUri())</span>
<span class="fc bfc" id="L2249" title="All 2 branches covered.">        &amp;&amp; localName.equals(TextSElement.ELEMENT_NAME.getLocalName());</span>
  }

  @Override
  /**
   * http://xerces.apache.org/xerces2-j/faq-sax.html#faq-2 : SAX may deliver contiguous text as
   * multiple calls to characters, for reasons having to do with parser efficiency and input
   * buffering. It is the programmer's responsibility to deal with that appropriately, e.g. by
   * accumulating text until the next non-characters event. This method will finalize the text of an
   * element, by flushing/appending it to the element node. It is called at the beginning of
   * startElement/endElement. In case of startElement the text will be referred to the previous
   * element node (before the new started). In case of endElement the text will be referred to the
   * current element node.
   */
  public void characters(char[] ch, int startPosition, int length) {
<span class="fc bfc" id="L2264" title="All 2 branches covered.">    if (mCurrentComponent instanceof TextContainer) {</span>
      // ODF Whitespacehandling
<span class="fc" id="L2266">      WhitespaceStatus currentWhiteSpaceStatus = mWhitespaceStatusStack.getLast();</span>
      // Note: The delta between startPosition and endPosition marks the text to be written out
      // startPosition will only be raised to endposition, when characters have to be skipped!
<span class="fc" id="L2269">      int endPosition = startPosition;</span>
<span class="fc" id="L2270">      int lastPos = startPosition + length;</span>
<span class="fc" id="L2271">      boolean previousContentWritten = false;</span>
      char c;
      // Go through all characters found by the parser..
<span class="fc bfc" id="L2274" title="All 2 branches covered.">      for (int i = startPosition; i &lt; lastPos; i++) {</span>
<span class="fc" id="L2275">        c = ch[i];</span>
        // first part is trimming in the beginning of the element
<span class="fc bfc" id="L2277" title="All 2 branches covered.">        if (currentWhiteSpaceStatus.hasOnlyWhiteSpace()) {</span>
          // \t (tabulator = 0x09)
<span class="pc bpc" id="L2279" title="1 of 8 branches missed.">          if (c == '\u0020' // space</span>
              || c == '\t'
              // \r (carriage return = 0x0D)
              || c == '\r'
              // \n (line feed = 0x0A)
              || c == '\n') {
            // skipt this character, keeping the difference between start &amp; end (length) equal
<span class="fc" id="L2286">            startPosition++;</span>
<span class="fc" id="L2287">            endPosition++;</span>
          } else {
            // first character being found worth to be written
<span class="fc" id="L2290">            currentWhiteSpaceStatus.setOnlyWhiteSpace(false);</span>
<span class="fc" id="L2291">            endPosition++;</span>
          }
          // second part is about collapsing multiple whitespaces
        } else {
<span class="pc bpc" id="L2295" title="1 of 8 branches missed.">          if (c == '\u0020' // space</span>
              || c == '\t' // \t (tabulator = 0x09)
              // \r (carriage return = 0x0D)
              || c == '\r'
              // \n (line feed = 0x0A)
              || c == '\n') {
            // if we have aleady a preceding whitespace character
<span class="fc bfc" id="L2302" title="All 2 branches covered.">            if (currentWhiteSpaceStatus.hasSpaceBefore()) {</span>
<span class="fc bfc" id="L2303" title="All 2 branches covered.">              if (!previousContentWritten) {</span>
                // as we have to skip a character in the array, write what we have
<span class="fc bfc" id="L2305" title="All 2 branches covered.">                if (endPosition - startPosition &gt; 0) {</span>
<span class="fc" id="L2306">                  mCharsForElement.append(ch, startPosition, endPosition - startPosition);</span>
                }
<span class="fc" id="L2308">                previousContentWritten = true;</span>
              }
              // NOT including this character
<span class="fc" id="L2311">              endPosition++;</span>
<span class="fc" id="L2312">              startPosition = endPosition;</span>
            } else {
<span class="fc" id="L2314">              currentWhiteSpaceStatus.setFirstSpaceCharPosition(i);</span>
<span class="fc" id="L2315">              ch[i] = '\u0020'; // overwrite all</span>
<span class="fc" id="L2316">              endPosition++;</span>
            }
          } else {
<span class="fc bfc" id="L2319" title="All 2 branches covered.">            if (currentWhiteSpaceStatus.hasSpaceBefore()) {</span>
<span class="fc" id="L2320">              currentWhiteSpaceStatus.setFirstSpaceCharPosition(-1);</span>
            }
<span class="fc" id="L2322">            endPosition++; // including this character</span>
          }
        }
      }
<span class="fc bfc" id="L2326" title="All 2 branches covered.">      if (endPosition - startPosition &gt; 0) {</span>
<span class="fc" id="L2327">        mCharsForElement.append(ch, startPosition, endPosition - startPosition);</span>
      }
<span class="fc" id="L2329">    } else {</span>
      /*
      * ToDo: The following will be ignored for now:
      In addition, OpenDocument Consumers shall ignore all element children ([RNG] section 5,
      Data Model) of elements defined in this specification that are strings consisting entirely of whitespace characters and
      which do not satisfy a pattern of the OpenDocument schema definition for the element.
      */
      // See
      // http://docs.oasis-open.org/office/v1.2/os/OpenDocument-v1.2-os-part1.html#a3_18White_Space_Processing_and_EOL_Handling
<span class="fc" id="L2338">      mCharsForElement.append(ch, startPosition, length);</span>
    }
<span class="fc" id="L2340">  }</span>

  @Override
  public InputSource resolveEntity(String publicId, String systemId)
      throws IOException, SAXException {
<span class="nc" id="L2345">    return super.resolveEntity(publicId, systemId);</span>
  }

  /**
   * This method is being called whenever an element being the root element is found, within
   * startElement function. It considers mComponentDepth and the size of the list
   * mLastComponentPositions. It updates the position (ie. list mLastComponentPositions) by adding a
   * child or a sibling. This ONLY works if mComponentDepth has already been updated before this
   * method is being called. Currently at the beginning of startElement, when realizing it is a
   * component root element.
   *
   * &lt;p&gt;The only reason to update the position (mLastComponentPositions) outside of this function is
   * to handle attributes representing repeatedColumns components * (i.e. for cells &amp; rows).
   *
   * @return the path of the current found component as Integer array
   */
  private List&lt;Integer&gt; updateComponentPosition() {
<span class="fc" id="L2362">    List&lt;Integer&gt; pos = updatePosition(true);</span>
<span class="fc" id="L2363">    return pos;</span>
  }

  /**
   * This method is being called whenever an element being the root element is found, within
   * startElement function. It considers mComponentDepth and the size of the list
   * mLastComponentPositions. It updates the position (ie. list mLastComponentPositions) by adding a
   * child or a sibling. This ONLY works if mComponentDepth has already been updated before this
   * method is being called. Currently at the beginning of startElement, when realizing it is a
   * component root element.
   *
   * &lt;p&gt;The only reason to update the position (mLastComponentPositions) outside of this function is
   * to handle attributes representing repeatedColumns components * (i.e. for cells &amp; rows).
   *
   * @return the path of the current found component as Integer array
   */
  private List&lt;Integer&gt; updateTextPosition() {
<span class="fc" id="L2380">    return updatePosition(false);</span>
  }

  /**
   * This method is being called whenever an element being the root element is found, within
   * startElement function. It considers mComponentDepth and the size of the list
   * mLastComponentPositions. It updates the position (ie. list mLastComponentPositions) by adding a
   * child or a sibling. This ONLY works if mComponentDepth has already been updated before this
   * method is being called. Currently at the beginning of startElement, when realizing it is a
   * component root element.
   *
   * &lt;p&gt;The only reason to update the position (mLastComponentPositions) outside of this function is
   * to handle attributes representing repeatedColumns components * (i.e. for cells &amp; rows).
   *
   * @return the path of the current found component as Integer array
   */
  private List&lt;Integer&gt; updatePosition(boolean isComponent) {
    /**
     * Used components being siblings of text, where the position is determined by the text count,
     * not by the previous component number
     */
    // take care of position handling
    // NEW COMPONENT CHILD: If the component Level is deeper than the last position
    // Actually at the first component: componentDepth start with 0, but the size with 1
<span class="fc bfc" id="L2404" title="All 2 branches covered.">    if (mComponentDepth == mLastComponentPositions.size()) {</span>
      // addChild a new level
<span class="fc" id="L2406">      mLastComponentPositions.add(mComponentDepth, 0);</span>

      // NEW SIBLING: If the depth is &quot;equal&quot; (ie. lower) than addChild a sibling
<span class="fc bfc" id="L2409" title="All 2 branches covered.">    } else if (mComponentDepth == mLastComponentPositions.size() - 1) {</span>
      int positionUpdate;
<span class="fc bfc" id="L2411" title="All 2 branches covered.">      if (mCurrentComponent instanceof TextContainer) {</span>
        // increment the last position number as a sibling was added
<span class="fc" id="L2413">        positionUpdate = mCurrentComponent.size();</span>
<span class="fc bfc" id="L2414" title="All 2 branches covered.">      } else if (mCurrentComponent instanceof Cell) {</span>
<span class="fc" id="L2415">        positionUpdate = mLastComponentPositions.get(mComponentDepth) + 1;</span>
        //            } else if (mCurrentComponent instanceof Table) {
        //                positionUpdate =mCurrentComponent.size();
<span class="pc bpc" id="L2418" title="1 of 2 branches missed.">      } else if (mCurrentComponent.getRootElement() instanceof OfficeAnnotationEndElement) {</span>
<span class="nc" id="L2419">        positionUpdate = mCurrentComponent.getParent().size();</span>
      } else {
<span class="fc" id="L2421">        positionUpdate = mLastComponentPositions.get(mComponentDepth) + 1;</span>
      }
<span class="fc" id="L2423">      mLastComponentPositions.set(mComponentDepth, positionUpdate);</span>
      // FINISHED COMPONENT - REMOVE DEPTH - If a component was closed and the position needds to be
      // added
<span class="pc bpc" id="L2426" title="1 of 2 branches missed.">    } else if (mComponentDepth &lt; mLastComponentPositions.size() - 1) {</span>
      // remove the last position and addChild a new one
<span class="fc" id="L2428">      mLastComponentPositions.removeLast();</span>
<span class="fc" id="L2429">      updatePosition(isComponent);</span>
    } else {
<span class="nc" id="L2431">      LOG.warning(&quot;Houston, we have a problem..&quot;);</span>
    }
    // ToDo: Do I need a new LIST for every component? Or may I addChild a position to the
    // component?
<span class="fc" id="L2435">    return new LinkedList&lt;Integer&gt;(mLastComponentPositions);</span>
    // ToDo: Below a bad idea?
    // return Collections.unmodifiableList(mLastComponentPositions);
  }

  /** @return the path of the current found component as Integer array */
  private List&lt;Integer&gt; getTextPosition() {
    // The text is one level further down
<span class="fc" id="L2443">    mComponentDepth++;</span>
<span class="fc" id="L2444">    List&lt;Integer&gt; position = updateTextPosition();</span>
<span class="fc" id="L2445">    mComponentDepth--;</span>
<span class="fc" id="L2446">    return position;</span>
  }

  // CachedTable mCachedTableOps = null;
  // based on document position the tables and subtables are being flushed after each end
  //    HashMap&lt;List&lt;Integer&gt;, CachedTable&gt; mAllTables = null;
  //    private ArrayList&lt;CachedTable&gt; mTableStack;
  //    boolean mWithinTable = false; //TODO: Detect via type of top element of mComponentStack
  // private int mNumberOfNestedTables = 0;
<span class="fc" id="L2455">  Stack&lt;CachedComponent&gt; mComponentStack = new Stack&lt;CachedComponent&gt;();</span>
  // cache objects bound to page that are on top level of the document
<span class="fc" id="L2457">  ArrayDeque&lt;ShapeProperties&gt; m_cachedPageShapes = new ArrayDeque&lt;ShapeProperties&gt;();</span>
<span class="fc" id="L2458">  boolean mPageBoundObjectsRelocated = false;</span>
<span class="fc" id="L2459">  HashMap&lt;String, Integer&gt; mTopLevelTables =</span>
      new HashMap&lt;String, Integer&gt;(); // mapping of spreadsheet index to their names

  @SuppressWarnings(&quot;unchecked&quot;)
  public void cacheOperation(
      boolean fillCacheOnly,
      String componentType,
      List&lt;Integer&gt; start,
      boolean absolutePosition,
      Map&lt;String, Object&gt; hardFormattingProperties,
      Object... componentProperties) {
<span class="fc bfc" id="L2470" title="All 2 branches covered.">    if (mComponentStack.empty()) {</span>
      // send to producer
<span class="fc bfc" id="L2472" title="All 2 branches covered.">      if (componentType.equals(OperationConstants.TEXT)) {</span>
<span class="fc" id="L2473">        String text = (String) componentProperties[0];</span>
<span class="fc" id="L2474">        String context = (String) componentProperties[1];</span>
<span class="fc" id="L2475">        mJsonOperationProducer.addText(start, text, context);</span>
<span class="fc bfc" id="L2476" title="All 2 branches covered.">      } else if (componentType.equals(OperationConstants.PARAGRAPH)) {</span>
<span class="fc" id="L2477">        String context = (String) componentProperties[0];</span>
<span class="fc" id="L2478">        mJsonOperationProducer.add(componentType, start, hardFormattingProperties, context);</span>
<span class="fc bfc" id="L2479" title="All 2 branches covered.">      } else if (componentType.equals(OperationConstants.TABLE)) {</span>
<span class="fc" id="L2480">        List&lt;Integer&gt; tableGrid = (List&lt;Integer&gt;) componentProperties[0];</span>
<span class="fc" id="L2481">        String tableName = (String) componentProperties[1];</span>
<span class="fc" id="L2482">        String context = (String) componentProperties[2];</span>
<span class="fc" id="L2483">        mJsonOperationProducer.addTable(</span>
            start, hardFormattingProperties, tableGrid, tableName, context);
<span class="pc bpc" id="L2485" title="1 of 2 branches missed.">      } else if (componentType.equals(OperationConstants.EXCEEDEDTABLE)) {</span>
<span class="nc" id="L2486">        int columns = (Integer) componentProperties[0];</span>
<span class="nc" id="L2487">        int rows = (Integer) componentProperties[1];</span>
<span class="nc" id="L2488">        List&lt;Integer&gt; tableGrid = (List&lt;Integer&gt;) componentProperties[2];</span>
<span class="nc" id="L2489">        String context = (String) componentProperties[3];</span>
        // addExceededTable(final List&lt;Integer&gt; start, int columns, int rows, final List&lt;Integer&gt;
        // tableGrid) {
<span class="nc" id="L2492">        mJsonOperationProducer.addExceededTable(start, columns, rows, tableGrid, context);</span>
<span class="pc bfc" id="L2493" title="All 2 branches covered.">      } else if (componentType.equals(OperationConstants.ATTRIBUTES)) {</span>
<span class="fc" id="L2494">        List&lt;Integer&gt; end = (List&lt;Integer&gt;) componentProperties[0];</span>
<span class="fc" id="L2495">        String context = (String) componentProperties[1];</span>
<span class="fc" id="L2496">        mJsonOperationProducer.format(start, end, hardFormattingProperties, context);</span>
<span class="pc bpc" id="L2497" title="1 of 2 branches missed.">      } else if (componentType.equals(OperationConstants.FORMATROWS)) {</span>
<span class="nc" id="L2498">        Integer firstRow = (Integer) componentProperties[0];</span>
<span class="nc" id="L2499">        Integer lastRow = (Integer) componentProperties[1];</span>
<span class="nc" id="L2500">        String context = (String) componentProperties[3];</span>
<span class="nc" id="L2501">        Integer repeatedRowOffset = (Integer) componentProperties[2];</span>
<span class="nc" id="L2502">        mJsonOperationProducer.formatRows(</span>
            start, hardFormattingProperties, firstRow, lastRow, repeatedRowOffset, context);
<span class="pc bpc" id="L2504" title="1 of 2 branches missed.">      } else if (componentType.equals(OperationConstants.FORMATCOLUMNS)) {</span>
<span class="nc" id="L2505">        Integer firstColumn = (Integer) componentProperties[0];</span>
<span class="nc" id="L2506">        Integer lastColumn = (Integer) componentProperties[1];</span>
<span class="nc" id="L2507">        String context = (String) componentProperties[2];</span>
<span class="nc" id="L2508">        mJsonOperationProducer.formatColumns(</span>
            start, hardFormattingProperties, firstColumn, lastColumn, context);
<span class="pc bfc" id="L2510" title="All 2 branches covered.">      } else if (componentType.equals(OperationConstants.SHAPE)</span>
<span class="fc bfc" id="L2511" title="All 2 branches covered.">          || componentType.equals(OperationConstants.SHAPE_GROUP)) {</span>
<span class="fc" id="L2512">        String context = (String) componentProperties[0];</span>
<span class="fc" id="L2513">        mJsonOperationProducer.addShape(</span>
            start,
            hardFormattingProperties,
            context,
<span class="fc" id="L2517">            componentType.equals(OperationConstants.SHAPE_GROUP));</span>
<span class="fc bfc" id="L2518" title="All 2 branches covered.">      } else if (componentType.equals(OperationConstants.IMAGE)) {</span>
<span class="fc" id="L2519">        String context = (String) componentProperties[0];</span>
<span class="fc" id="L2520">        mJsonOperationProducer.addImage(start, hardFormattingProperties, context);</span>
<span class="fc bfc" id="L2521" title="All 2 branches covered.">      } else if (componentType.equals(OperationConstants.FIELD)) {</span>
<span class="fc" id="L2522">        String fieldType = (String) componentProperties[0];</span>
<span class="fc" id="L2523">        String fieldContent = (String) componentProperties[1];</span>
<span class="fc" id="L2524">        Map&lt;String, Object&gt; fieldAttributes = (Map&lt;String, Object&gt;) componentProperties[2];</span>
<span class="fc" id="L2525">        String context = (String) componentProperties[3];</span>
<span class="fc" id="L2526">        mJsonOperationProducer.addField(start, fieldType, fieldContent, fieldAttributes, context);</span>
<span class="fc bfc" id="L2527" title="All 2 branches covered.">      } else if (componentType.equals(OperationConstants.COMMENT)) {</span>
<span class="fc" id="L2528">        String id = (String) componentProperties[0];</span>
<span class="fc" id="L2529">        String author = (String) componentProperties[1];</span>
<span class="fc" id="L2530">        String date = (String) componentProperties[2];</span>
<span class="fc" id="L2531">        String target = (String) componentProperties[3];</span>
<span class="fc" id="L2532">        mJsonOperationProducer.addAnnotation(start, id, author, date, target);</span>
<span class="fc bfc" id="L2533" title="All 2 branches covered.">      } else if (componentType.equals(OperationConstants.COMMENTRANGE)) {</span>
<span class="fc" id="L2534">        String id = (String) componentProperties[0];</span>
<span class="fc" id="L2535">        String target = (String) componentProperties[1];</span>
<span class="fc" id="L2536">        mJsonOperationProducer.addRange(start, id, target);</span>
<span class="fc bfc" id="L2537" title="All 2 branches covered.">      } else if (componentType.equals(OperationConstants.TAB)) {</span>
<span class="fc" id="L2538">        String target = (String) componentProperties[0];</span>
<span class="fc" id="L2539">        mJsonOperationProducer.add(</span>
<span class="pc bpc" id="L2540" title="1 of 2 branches missed.">            componentType, start, hardFormattingProperties, target != null ? target : mContextName);</span>
<span class="fc" id="L2541">      } else {</span>
<span class="fc" id="L2542">        String target = (String) componentProperties[0];</span>
<span class="fc" id="L2543">        mJsonOperationProducer.add(</span>
<span class="fc bfc" id="L2544" title="All 2 branches covered.">            componentType, start, hardFormattingProperties, target != null ? target : mContextName);</span>
<span class="fc" id="L2545">      }</span>
    } else {
<span class="fc" id="L2547">      CachedComponent topComponent = mComponentStack.peek();</span>
<span class="fc bfc" id="L2548" title="All 4 branches covered.">      if (!fillCacheOnly &amp;&amp; topComponent instanceof CachedTable) {</span>
<span class="fc" id="L2549">        cacheTableOperation(componentType, start, hardFormattingProperties, componentProperties);</span>
      } else {
        // collect the operations at the CachedComponent
<span class="fc" id="L2552">        LinkedList&lt;Integer&gt; position = null;</span>
<span class="pc bpc" id="L2553" title="1 of 2 branches missed.">        if (start != null) {</span>
<span class="fc" id="L2554">          position = new LinkedList&lt;&gt;(start);</span>
        }

<span class="fc" id="L2557">        topComponent.add(</span>
            new CachedOperation(
                componentType,
                position,
                absolutePosition,
                hardFormattingProperties,
                componentProperties));
      }
    }
<span class="fc" id="L2566">  }</span>

  /** Table operation are being cached in one of two caches */
  @SuppressWarnings(&quot;unchecked&quot;)
  private void /*CachedTable */ cacheTableOperation(
      /*CachedTable currentTable,*/ String componentType,
      List&lt;Integer&gt; start,
      Map&lt;String, Object&gt; hardFormattingProperties,
      Object... componentProperties) {
<span class="fc" id="L2575">    LinkedList&lt;Integer&gt; position = null;</span>
    CachedTable currentTable =
<span class="fc bfc" id="L2577" title="All 2 branches covered.">        mComponentStack.empty()</span>
<span class="fc" id="L2578">            ? null</span>
<span class="fc bfc" id="L2579" title="All 2 branches covered.">            : (mComponentStack.peek() instanceof CachedTable)</span>
<span class="fc" id="L2580">                ? (CachedTable) mComponentStack.peek()</span>
<span class="fc" id="L2581">                : null;</span>
<span class="pc bpc" id="L2582" title="1 of 2 branches missed.">    if (start != null) {</span>
<span class="fc" id="L2583">      position = new LinkedList&lt;Integer&gt;(start);</span>
    }
<span class="fc bfc" id="L2585" title="All 2 branches covered.">    if (componentType.equals(OperationConstants.CELLS)) { // does not effect a spreadsheet</span>
<span class="fc" id="L2586">      currentTable.mCellCount++;</span>
<span class="pc bpc" id="L2587" title="3 of 4 branches missed.">      if (mMaxAllowedCellCount != 0 &amp;&amp; currentTable.mCellCount &gt; mMaxAllowedCellCount) {</span>
<span class="nc" id="L2588">        currentTable.mIsTooLarge = true;</span>
      }
<span class="fc bfc" id="L2590" title="All 2 branches covered.">    } else if (componentType.equals(OperationConstants.ROWS)) { // Counting Rows</span>
<span class="fc" id="L2591">      currentTable.mRowCount++; // no repeated in writer</span>
<span class="pc bpc" id="L2592" title="3 of 4 branches missed.">      if (mMaxAllowedRowCount != 0 &amp;&amp; currentTable.mRowCount &gt; mMaxAllowedRowCount) {</span>
<span class="nc" id="L2593">        currentTable.mIsTooLarge = true;</span>
      }
<span class="fc bfc" id="L2595" title="All 2 branches covered.">    } else if (componentType.equals(</span>
        OperationConstants.TABLE)) { // all formats (Text &amp; Spreadsheet atm)
<span class="fc" id="L2597">      List&lt;Integer&gt; tableGrid = (List&lt;Integer&gt;) componentProperties[0];</span>
<span class="fc" id="L2598">      CachedTable newCachedTable = startTableSizeEvaluation(position, tableGrid);</span>
<span class="pc bpc" id="L2599" title="1 of 2 branches missed.">      if (newCachedTable.mTableGrid != null) {</span>
<span class="pc bpc" id="L2600" title="1 of 2 branches missed.">        if (mMaxAllowedColumnCount != 0</span>
<span class="nc bnc" id="L2601" title="All 2 branches missed.">            &amp;&amp; newCachedTable.mTableGrid.size() &gt; mMaxAllowedColumnCount) {</span>
<span class="nc" id="L2602">          newCachedTable.mIsTooLarge = true;</span>
          // adding the table now, as it would not be below as already too large..
        } else {
<span class="fc" id="L2605">          newCachedTable.mColumnCount = newCachedTable.mTableGrid.size();</span>
        }
      }
      // if it is the first root table
<span class="fc bfc" id="L2609" title="All 2 branches covered.">      if (currentTable == null) {</span>
        // only for the root table the table itself will be added at the beginning
<span class="fc" id="L2611">        currentTable = newCachedTable;</span>
        //                ++currentTable.mNumberOfNestedTables;
<span class="fc" id="L2613">        mComponentStack.push(currentTable);</span>
<span class="fc" id="L2614">        currentTable.add(</span>
            new CachedInnerTableOperation(
                componentType, position, false, hardFormattingProperties, componentProperties));
      } else { // as subtable the table will be added twice:
        // once for the parent as notifier
<span class="fc" id="L2619">        currentTable.addSubTable(newCachedTable, start);</span>
<span class="fc" id="L2620">        currentTable.add(</span>
            new CachedInnerTableOperation(
                componentType, position, false, hardFormattingProperties, componentProperties));
<span class="fc" id="L2623">        currentTable = newCachedTable;</span>
        // once for the child to create
<span class="fc" id="L2625">        currentTable.add(</span>
            new CachedInnerTableOperation(
                componentType, position, false, hardFormattingProperties, componentProperties));
      }
    }
<span class="pc bpc" id="L2630" title="1 of 2 branches missed.">    if (!currentTable.mIsTooLarge</span>
<span class="fc bfc" id="L2631" title="All 2 branches covered.">        &amp;&amp; !componentType.equals(OperationConstants.TABLE)</span>
<span class="pc bpc" id="L2632" title="1 of 2 branches missed.">        &amp;&amp; !componentType.equals(OperationConstants.COLUMNS)) {</span>
<span class="fc" id="L2633">      currentTable.add(</span>
          new CachedInnerTableOperation(
              componentType, position, false, hardFormattingProperties, componentProperties));
    }
<span class="fc" id="L2637">  }</span>

  /**
   * According to user run-time configuration only tables of a certain size are allowed to be
   * created. Tables exceeding the limit are being shown by a replacement object, otherwise the
   * client performance might not be sufficient.
   */
  private CachedTable startTableSizeEvaluation(List&lt;Integer&gt; position, List&lt;Integer&gt; tableGrid) {
<span class="fc" id="L2645">    CachedTable cachedTable = null;</span>

<span class="fc" id="L2647">    cachedTable = new CachedTable();</span>

<span class="fc" id="L2649">    cachedTable.mTableGrid = tableGrid;</span>
<span class="fc" id="L2650">    return cachedTable;</span>
  }

  /**
   * According to user run-time configuration only tables of a certain size are allowed to be
   * created. Tables exceeding the limit are being shown by a replacement object, otherwise the
   * client performance might not be sufficient.
   *
   * &lt;p&gt;As the limit is being checked on sub table level, the complete table have to be parsed
   * before giving green light for any table. On the opposite, if a subtable is already too large,
   * it can be neglected collecting operations for that subtable.
   *
   * @throws SAXException
   */
  private void endTableSizeEvaluation() throws SAXException {

<span class="fc" id="L2666">    CachedTable cachedTableOps = (CachedTable) mComponentStack.peek();</span>
<span class="fc bfc" id="L2667" title="All 2 branches covered.">    if (cachedTableOps.getSubTableCount() == 0) {</span>
<span class="fc" id="L2668">      cachedTableOps.mMostUsedColumnStyle = getMostUsedStyle(cachedTableOps.columnStyleOccurrence);</span>
<span class="fc" id="L2669">      cachedTableOps.mMostUsedRowStyle = getMostUsedStyle(cachedTableOps.rowStyleOccurrence);</span>
<span class="fc" id="L2670">      mComponentStack.pop();</span>
<span class="fc" id="L2671">      flushTableOperations(cachedTableOps, true);</span>
<span class="pc bpc" id="L2672" title="2 of 4 branches missed.">      if (cachedTableOps != null &amp;&amp; cachedTableOps.mCachedTableContentOps != null) {</span>
<span class="nc" id="L2673">        cachedTableOps.mCachedTableContentOps = null;</span>
<span class="nc" id="L2674">        cachedTableOps.lastRowFormatOperation = null;</span>
      }
<span class="pc bpc" id="L2676" title="1 of 2 branches missed.">    } else if (cachedTableOps.getSubTableCount() &gt; 0) {</span>
      // when leaving a table, continue with the parent table
<span class="fc" id="L2678">      cachedTableOps.removeSubTable();</span>
    } else { // below zero might appear, when table had started in blocked area
      // TODO: is it really possible to reach this point?
<span class="nc bnc" id="L2681" title="All 4 branches missed.">      if (cachedTableOps != null &amp;&amp; cachedTableOps.mCachedTableContentOps != null) {</span>
<span class="nc" id="L2682">        cachedTableOps.mCachedTableContentOps = null;</span>
<span class="nc" id="L2683">        cachedTableOps.lastRowFormatOperation = null;</span>
      }
<span class="nc" id="L2685">      mComponentStack.pop();</span>
    }
<span class="fc" id="L2687">  }</span>

  @SuppressWarnings(&quot;rawtypes&quot;)
  private void flushTableOperations(CachedTable currentTable, boolean isStartOfTable)
      throws SAXException {

<span class="fc" id="L2693">    boolean putPageBreak = false;</span>
<span class="fc" id="L2694">    boolean isBreakBefore = true;</span>
<span class="fc" id="L2695">    ListIterator&lt;CachedOperation&gt; cachedOperationIterator = currentTable.listIterator();</span>
<span class="fc bfc" id="L2696" title="All 2 branches covered.">    while (cachedOperationIterator.hasNext()) {</span>
<span class="fc" id="L2697">      CachedOperation operation = cachedOperationIterator.next();</span>
<span class="fc bfc" id="L2698" title="All 2 branches covered.">      if (operation instanceof CachedInnerTableOperation</span>
<span class="fc bfc" id="L2699" title="All 2 branches covered.">          &amp;&amp; operation.mComponentType.equals(OperationConstants.TABLE)) {</span>
<span class="fc bfc" id="L2700" title="All 2 branches covered.">        if (isStartOfTable) {</span>
<span class="fc" id="L2701">          isStartOfTable = false;</span>
<span class="pc bpc" id="L2702" title="1 of 2 branches missed.">          if (currentTable.mIsTooLarge) {</span>
            // replacement table
<span class="nc" id="L2704">            cacheOperation(</span>
                false,
                OperationConstants.EXCEEDEDTABLE,
                operation.mStart,
                false,
                null,
<span class="nc" id="L2710">                ((List) operation.mComponentProperties[0]).size(),</span>
<span class="nc" id="L2711">                currentTable.mRowCount,</span>
                operation.mComponentProperties[0],
                mContextName);
<span class="nc" id="L2714">            break;</span>
          } else {
<span class="pc bpc" id="L2716" title="9 of 12 branches missed.">            if ((mMaxAllowedRowCount != 0 &amp;&amp; currentTable.mRowCount &gt; mMaxAllowedRowCount)</span>
                || (mMaxAllowedColumnCount != 0
                    &amp;&amp; currentTable.mColumnCount &gt; mMaxAllowedColumnCount)
                || (mMaxAllowedCellCount != 0 &amp;&amp; currentTable.mCellCount &gt; mMaxAllowedCellCount)) {
              // TODO: Exceeded table operation name
<span class="nc" id="L2721">              cacheOperation(</span>
                  false,
                  OperationConstants.EXCEEDEDTABLE,
                  operation.mStart,
                  false,
                  null,
<span class="nc" id="L2727">                  ((List) operation.mComponentProperties[0]).size(),</span>
<span class="nc" id="L2728">                  currentTable.mRowCount,</span>
                  operation.mComponentProperties[0],
                  mContextName);
<span class="nc" id="L2731">              break;</span>
            } else {
              // the last parameter are: mColumnRelWidths, mTableName, mIsTableVisible);
<span class="fc" id="L2734">              JSONObject tableAttr = null;</span>
<span class="fc bfc" id="L2735" title="All 2 branches covered.">              if (operation.mHardFormattingProperties.containsKey(&quot;table&quot;)</span>
<span class="fc" id="L2736">                  &amp;&amp; (((tableAttr = (JSONObject) operation.mHardFormattingProperties.get(&quot;table&quot;))</span>
<span class="fc bfc" id="L2737" title="All 2 branches covered.">                          .has(&quot;pageBreakBefore&quot;))</span>
<span class="pc bpc" id="L2738" title="1 of 2 branches missed.">                      || tableAttr.has(&quot;pageBreakAfter&quot;))) {</span>
<span class="fc" id="L2739">                isBreakBefore = tableAttr.has(&quot;pageBreakBefore&quot;);</span>
<span class="pc bpc" id="L2740" title="1 of 2 branches missed.">                String breakString = isBreakBefore ? &quot;pageBreakBefore&quot; : &quot;pageBreakAfter&quot;;</span>
<span class="fc" id="L2741">                boolean breakAttr = tableAttr.getBoolean(breakString);</span>
<span class="fc bfc" id="L2742" title="All 2 branches covered.">                if (breakAttr) {</span>
<span class="fc" id="L2743">                  putPageBreak = true;</span>
                }
<span class="fc" id="L2745">                tableAttr.remove(breakString);</span>
              }
<span class="fc" id="L2747">              cacheOperation(</span>
                  false,
                  OperationConstants.TABLE,
                  operation.mStart,
                  false,
                  operation.mHardFormattingProperties,
                  operation.mComponentProperties[0],
                  operation.mComponentProperties[1],
                  mContextName);
<span class="fc" id="L2756">            }</span>
          }
        } else {
<span class="fc" id="L2759">          flushTableOperations(currentTable.getSubTable(operation.mStart), true);</span>
        }
<span class="fc bfc" id="L2761" title="All 2 branches covered.">      } else if (operation.mComponentType.equals(OperationConstants.TEXT)) {</span>
<span class="fc" id="L2762">        String context = mContextName;</span>
<span class="pc bpc" id="L2763" title="1 of 4 branches missed.">        if (operation.mComponentProperties.length &gt; 1</span>
            &amp;&amp; operation.mComponentProperties[1] != null) {
<span class="fc" id="L2765">          context = (String) operation.mComponentProperties[1];</span>
        }
<span class="fc" id="L2767">        cacheOperation(</span>
            false,
            operation.mComponentType,
            operation.mStart,
            false,
            null,
            operation.mComponentProperties[0],
            context);
<span class="fc bfc" id="L2775" title="All 2 branches covered.">      } else if (operation.mComponentType.equals(OperationConstants.ATTRIBUTES)) {</span>
<span class="fc" id="L2776">        String context = mContextName;</span>
<span class="pc bpc" id="L2777" title="1 of 4 branches missed.">        if (operation.mComponentProperties.length &gt; 1</span>
            &amp;&amp; operation.mComponentProperties[1] != null) {
<span class="fc" id="L2779">          context = (String) operation.mComponentProperties[1];</span>
        }
<span class="fc" id="L2781">        cacheOperation(</span>
            false,
            OperationConstants.ATTRIBUTES,
            operation.mStart,
            false,
            operation.mHardFormattingProperties,
            operation.mComponentProperties[0],
            context);
<span class="fc bfc" id="L2789" title="All 2 branches covered.">      } else if (operation.mComponentType.equals(OperationConstants.SHAPE)</span>
<span class="fc bfc" id="L2790" title="All 2 branches covered.">          || operation.mComponentType.equals(OperationConstants.IMAGE)</span>
<span class="pc bpc" id="L2791" title="1 of 2 branches missed.">          || operation.mComponentType.equals(OperationConstants.SHAPE_GROUP)) {</span>
<span class="fc" id="L2792">        cacheOperation(</span>
            false,
            operation.mComponentType,
            operation.mStart,
            false,
            operation.mHardFormattingProperties,
            mContextName);
<span class="fc bfc" id="L2799" title="All 2 branches covered.">      } else if (operation.mComponentType.equals(OperationConstants.FIELD)) {</span>
        // TODO: Why do I have to check for map&lt;&gt; casts but not with String casts?
        @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L2802">        Map&lt;String, Object&gt; attrMap = (Map&lt;String, Object&gt;) operation.mComponentProperties[2];</span>
<span class="fc" id="L2803">        cacheOperation(</span>
            false,
            operation.mComponentType,
            operation.mStart,
            false,
            null,
            operation.mComponentProperties[0],
            operation.mComponentProperties[1],
            attrMap,
            mContextName);
<span class="pc bpc" id="L2813" title="1 of 2 branches missed.">      } else if (operation.mComponentType.equals(OperationConstants.TABLE)</span>
<span class="pc bpc" id="L2814" title="1 of 2 branches missed.">          || operation.mComponentType.equals(OperationConstants.COMMENT)</span>
<span class="pc bpc" id="L2815" title="1 of 2 branches missed.">          || operation.mComponentType.equals(OperationConstants.COMMENTRANGE)) {</span>
<span class="nc" id="L2816">        cacheOperation(</span>
            false,
            operation.mComponentType,
            operation.mStart,
            false,
            operation.mHardFormattingProperties,
            operation.mComponentProperties);
<span class="pc bpc" id="L2823" title="1 of 2 branches missed.">      } else if (operation.mComponentType.equals(OperationConstants.COMMENT)</span>
<span class="pc bpc" id="L2824" title="1 of 2 branches missed.">          || operation.mComponentType.equals(OperationConstants.COMMENTRANGE)) {</span>
<span class="nc" id="L2825">        cacheOperation(</span>
            false,
            operation.mComponentType,
            operation.mStart,
            false,
            operation.mHardFormattingProperties,
            operation.mComponentProperties);
      } else {
<span class="fc" id="L2833">        boolean isParagraphOperation =</span>
<span class="fc" id="L2834">            operation.mComponentType.equals(OperationConstants.PARAGRAPH);</span>
<span class="fc bfc" id="L2835" title="All 4 branches covered.">        if (putPageBreak &amp;&amp; isParagraphOperation) {</span>
<span class="fc" id="L2836">          JSONObject paraProps = null;</span>
<span class="pc bpc" id="L2837" title="1 of 2 branches missed.">          if (operation.mHardFormattingProperties == null) {</span>
<span class="nc" id="L2838">            operation.mHardFormattingProperties = new HashMap&lt;String, Object&gt;();</span>
          }
<span class="pc bpc" id="L2840" title="1 of 2 branches missed.">          if (!operation.mHardFormattingProperties.containsKey(&quot;paragraph&quot;)) {</span>
<span class="fc" id="L2841">            paraProps = new JSONObject();</span>
          } else {
<span class="nc" id="L2843">            paraProps = (JSONObject) operation.mHardFormattingProperties.get(&quot;paragraph&quot;);</span>
          }
<span class="pc bpc" id="L2845" title="1 of 2 branches missed.">          paraProps.put(isBreakBefore ? &quot;pageBreakBefore&quot; : &quot;pageBreakAfter&quot;, true);</span>
<span class="fc" id="L2846">          operation.mHardFormattingProperties.put(&quot;paragraph&quot;, paraProps);</span>
<span class="fc" id="L2847">          putPageBreak = false;</span>
        }
<span class="fc" id="L2849">        String context = mContextName;</span>
<span class="fc bfc" id="L2850" title="All 4 branches covered.">        if (isParagraphOperation &amp;&amp; operation.mComponentProperties[0] != null) {</span>
<span class="fc" id="L2851">          context = (String) operation.mComponentProperties[0];</span>
        }
<span class="fc" id="L2853">        cacheOperation(</span>
            false,
            operation.mComponentType,
            operation.mStart,
            false,
            operation.mHardFormattingProperties,
            context);
      }
<span class="fc" id="L2861">    }</span>
<span class="fc" id="L2862">  }</span>

  private static String getMostUsedStyle(Map&lt;String, Integer&gt; styleOccurrances) {
<span class="fc" id="L2865">    String mostUsedStyleName = null;</span>
<span class="pc bpc" id="L2866" title="1 of 2 branches missed.">    if (styleOccurrances != null) {</span>
<span class="nc" id="L2867">      Set&lt;Entry&lt;String, Integer&gt;&gt; entrySet = styleOccurrances.entrySet();</span>
<span class="nc" id="L2868">      Iterator&lt;Entry&lt;String, Integer&gt;&gt; iter = entrySet.iterator();</span>
<span class="nc" id="L2869">      Integer styleOccurance = null;</span>
<span class="nc" id="L2870">      Integer styleOccuranceMax = null;</span>
<span class="nc bnc" id="L2871" title="All 2 branches missed.">      while (iter.hasNext()) {</span>
<span class="nc" id="L2872">        Entry&lt;String, Integer&gt; entry = iter.next();</span>
<span class="nc" id="L2873">        styleOccurance = entry.getValue();</span>
<span class="nc bnc" id="L2874" title="All 4 branches missed.">        if (styleOccuranceMax == null || styleOccuranceMax &lt; styleOccurance) {</span>
<span class="nc" id="L2875">          styleOccuranceMax = styleOccurance;</span>
<span class="nc" id="L2876">          mostUsedStyleName = entry.getKey();</span>
        }
<span class="nc" id="L2878">      }</span>
      // if there is a most used style
<span class="nc bnc" id="L2880" title="All 2 branches missed.">      if (mostUsedStyleName != null) {</span>
        // make sure it is not by coincidence the most single used one..
<span class="nc bnc" id="L2882" title="All 2 branches missed.">        if (styleOccurrances.get(mostUsedStyleName) == 1) {</span>
<span class="nc" id="L2883">          mostUsedStyleName = null;</span>
        }
      }
    }

<span class="fc" id="L2888">    return mostUsedStyleName;</span>
  }

  private JSONObject getHeaderFooterAttrs(OdfElement e) {
<span class="fc" id="L2892">    JSONObject attrs = null;</span>
<span class="fc" id="L2893">    JSONObject pageAttrs = null;</span>
<span class="fc bfc" id="L2894" title="All 2 branches covered.">    if (e != null) {</span>
<span class="fc" id="L2895">      final Element p =</span>
<span class="fc" id="L2896">          e.getChildElement(</span>
<span class="fc" id="L2897">              StyleHeaderFooterPropertiesElement.ELEMENT_NAME.getUri(), &quot;header-footer-properties&quot;);</span>
<span class="fc bfc" id="L2898" title="All 2 branches covered.">      if (p != null) {</span>
<span class="fc" id="L2899">        pageAttrs = new JSONObject(3);</span>
<span class="fc" id="L2900">        final String sMinHeight = p.getAttribute(&quot;fo:min-height&quot;);</span>
<span class="fc bfc" id="L2901" title="All 2 branches covered.">        if (!sMinHeight.isEmpty()) {</span>
<span class="fc" id="L2902">          pageAttrs.put(&quot;minHeight&quot;, MapHelper.normalizeLength(sMinHeight));</span>
        }
<span class="fc" id="L2904">        final String sHeight = p.getAttribute(&quot;svg:height&quot;);</span>
<span class="fc bfc" id="L2905" title="All 2 branches covered.">        if (!sHeight.isEmpty()) {</span>
<span class="fc" id="L2906">          pageAttrs.put(&quot;height&quot;, MapHelper.normalizeLength(sHeight));</span>
        }
<span class="fc" id="L2908">        final String sMarginTop = p.getAttribute(&quot;fo:margin-top&quot;);</span>
<span class="fc bfc" id="L2909" title="All 2 branches covered.">        if (!sMarginTop.isEmpty()) {</span>
<span class="fc" id="L2910">          pageAttrs.put(&quot;marginTop&quot;, MapHelper.normalizeLength(sMarginTop));</span>
        }
<span class="fc" id="L2912">        final String sMarginBottom = p.getAttribute(&quot;fo:margin-bottom&quot;);</span>
<span class="fc bfc" id="L2913" title="All 2 branches covered.">        if (!sMarginBottom.isEmpty()) {</span>
<span class="fc" id="L2914">          pageAttrs.put(&quot;marginBottom&quot;, MapHelper.normalizeLength(sMarginBottom));</span>
        }
<span class="fc" id="L2916">        final String sMarginLeft = p.getAttribute(&quot;fo:margin-left&quot;);</span>
<span class="fc bfc" id="L2917" title="All 2 branches covered.">        if (!sMarginLeft.isEmpty()) {</span>
<span class="fc" id="L2918">          pageAttrs.put(&quot;marginLeft&quot;, MapHelper.normalizeLength(sMarginLeft));</span>
        }
<span class="fc" id="L2920">        final String sMarginRight = p.getAttribute(&quot;fo:margin-right&quot;);</span>
<span class="fc bfc" id="L2921" title="All 2 branches covered.">        if (!sMarginRight.isEmpty()) {</span>
<span class="fc" id="L2922">          pageAttrs.put(&quot;marginRight&quot;, MapHelper.normalizeLength(sMarginRight));</span>
        }
      }
    }
<span class="pc bpc" id="L2926" title="1 of 4 branches missed.">    if (pageAttrs != null &amp;&amp; pageAttrs.length() != 0) {</span>
<span class="fc" id="L2927">      attrs = new JSONObject(1);</span>
<span class="fc" id="L2928">      attrs.put(&quot;page&quot;, pageAttrs);</span>
    }

<span class="fc" id="L2931">    return attrs;</span>
  }

  /**
   * Optimizes the operations of spreadsheet cells neglecting starting/trailing empty cells and for
   * cells with content or style bundling similar cells to single operations.
   *
   * &lt;p&gt;Repeated rows are automatically a range.
   *
   * &lt;p&gt;There are three pointer (variables), that are updated during parsing the spreadsheet:
   * mCurrentCellNo is the actual column number mFirstContentCellNo is mFirstEqualCellNo is set to
   * the first cell to be written, after a cell was written out or an empty precessor
   *
   * &lt;p&gt;ToDo: Refactoring - As soon every component got its own parser, the tableOps. have to be
   * replaced by the Context of the component
   *
   * &lt;p&gt;private CachedTable evaluateSimilarCells(CachedTable tableOps, CachedInnerTableOperation
   * cellOperation, JSONObject currentCell, boolean isRow) { // An Operation will always be
   * triggered in the end of the function boolean triggerOperation = false;
   *
   * &lt;p&gt;// every repeatedColumns row will result into a fillRange operation int
   * previousContentRepetition = 1;
   *
   * &lt;p&gt;// if the previous cells are equal if (tableOps.mFirstEqualCellNo &gt; -1) {
   * previousContentRepetition = tableOps.mCurrentColumnNo - tableOps.mFirstEqualCellNo; }
   *
   * &lt;p&gt;boolean isRepeatedRow = tableOps.mLastRow != null &amp;&amp;
   * !tableOps.mFirstRow.equals(tableOps.mLastRow);
   *
   * &lt;p&gt;// do not trigger the operation if the spreadsheetRow is null and its only member is null if
   * (tableOps.mSheetNo == null &amp;&amp; cellOperation != null &amp;&amp; cellOperation.mStart != null) { // we
   * have a cell position and require the two above (first parent row, afterwards cell) =&gt; already
   * -2 // and an additional - 1 as size of 1 would result in zero position ==&gt; finally -3
   * tableOps.mSheetNo = cellOperation.mStart.get(cellOperation.mStart.size() - 3); } // ** There
   * are four variations for previous/current cell we have to check: // 1) Current Content Cell,
   * Previous Content empty if (currentCell != null &amp;&amp; tableOps.mPreviousCell != null) { // if the
   * two cells are NOT the same if (!currentCell.equals(tableOps.mPreviousCell)) { if
   * (previousContentRepetition &gt; MIN_REPEATING_CONTENT_CELLS) { triggerOperation = true; } else {
   * if (tableOps.mCurrentRange == null) { tableOps.mCurrentRange = new JSONArray(); } // Resolving
   * mColumnRepetition, explicitly adding cells to the range for (int i = 0;
   * tableOps.mCurrentColumnNo - tableOps.mFirstEqualCellNo &gt; i; i++) {
   * tableOps.mCurrentRange.put(tableOps.mPreviousCell); } // if the row is being repeated, there
   * are always vertical spans (fill same content multiple times if (tableOps.mLastRow -
   * tableOps.mFirstRow &gt; 0) { triggerOperation = true; } // there is an upcoming fill operation,
   * the previous content has to be flushed if (tableOps.getCellRepetition() &gt;
   * MIN_REPEATING_CONTENT_CELLS) { triggerOperation = true; } tableOps.mFirstEqualCellNo =
   * tableOps.mCurrentColumnNo; } } // 2) Current Content Cell, Previous Empty Cell (never have
   * saved anything) } else if (currentCell != null &amp;&amp; tableOps.mPreviousCell == null) { // &amp;&amp;
   * tableOps.mCurrentRange == null tableOps.mFirstEqualCellNo = tableOps.mCurrentColumnNo; if
   * (tableOps.mFirstContentCellNo == -1) { // reset the empty cell counter - if previous was empty
   * tableOps.mFirstContentCellNo = tableOps.mCurrentColumnNo; tableOps.mEmptyCellCount = 0; } else
   * { if (tableOps.getCellRepetition() &gt; MIN_REPEATING_CONTENT_CELLS) { triggerOperation = true; }
   * else { if (tableOps.mCurrentRange == null) { tableOps.mCurrentRange = new JSONArray(); } for
   * (int i = 0; tableOps.mEmptyCellCount &gt; i; i++) { tableOps.mCurrentRange.put(JSONObject.NULL); }
   * tableOps.mEmptyCellCount = 0; } } // 3) Content Cell empty, Previo Cell full } else if
   * (currentCell == null &amp;&amp; tableOps.mPreviousCell != null) { tableOps.mEmptyCellCount +=
   * tableOps.getCellRepetition(); // as there had been previously content // check if it was
   * repeating content if (previousContentRepetition &gt; MIN_REPEATING_CONTENT_CELLS) {
   * triggerOperation = true; } else { if (tableOps.mCurrentRange == null) { tableOps.mCurrentRange
   * = new JSONArray(); } // save the previous cell for later compressed output for (int i = 0;
   * tableOps.mCurrentColumnNo - tableOps.mFirstEqualCellNo &gt; i; i++) {
   * tableOps.mCurrentRange.put(tableOps.mPreviousCell); } // if the row is being repeated, there
   * are always vertical spans (fill same content multiple times if (tableOps.mLastRow -
   * tableOps.mFirstRow &gt; 0) { triggerOperation = true; } } tableOps.mFirstEqualCellNo = -1; // if
   * there was previously repeating content cells // 4) Both are null } else if (currentCell == null
   * &amp;&amp; tableOps.mPreviousCell == null &amp; !isRow) { // note that an empty cell was passed
   * tableOps.mEmptyCellCount += tableOps.getCellRepetition(); // if this is the first empty cell if
   * (tableOps.mFirstEmptyCell == -1) { // remember when it started tableOps.mFirstEmptyCell =
   * tableOps.mCurrentColumnNo;
   *
   * &lt;p&gt;// else check if the maximum repeated empty cells was reached and existing content has to be
   * dispatched as an operation } else if (tableOps.mFirstContentCellNo != -1 &amp;&amp;
   * MAX_REPEATING_EMPTY_CELLS &gt; tableOps.mEmptyCellCount) { triggerOperation = true; } }
   *
   * &lt;p&gt;// RANGE CREATION: for every row we flush previous content OR if we want to flush for other
   * reasons if (isRow &amp;&amp; tableOps.mFirstContentCellNo &gt; -1 || triggerOperation) { // WRITING
   * WHITESPACE TO ROW // if the last cell used content, but there was previous whitespace, the
   * whitespace has to be explicitly set if (tableOps.mEmptyCellCount &gt; 0 &amp;&amp; currentCell != null) {
   * for (int i = 0; tableOps.mEmptyCellCount &gt; i; i++) { if (tableOps.mCurrentRange == null) {
   * tableOps.mCurrentRange = new JSONArray(); } tableOps.mCurrentRange.put(JSONObject.NULL); }
   * tableOps.mEmptyCellCount = 0; } // WRITING CELL TO ROW // if content to flush exist and the
   * operation was triggered // OR there is horizontal repeated content // OR there is vertical
   * repeated content if (tableOps.mCurrentRange != null || previousContentRepetition &gt;
   * MIN_REPEATING_CONTENT_CELLS || isRepeatedRow) { if(tableOps.mCurrentRange != null &amp;&amp;
   * !tableOps.mCurrentRange.isEmpty()) { Component rootComponent = mSchemaDoc.getRootComponent();
   * TableTableElement sheet = (TableTableElement)rootComponent.getChildNode(tableOps.mSheetNo); }
   *
   * &lt;p&gt;mJsonOperationProducer.addRange(tableOps.mSheetNo, tableOps.mFirstRow, tableOps.mLastRow,
   * tableOps.mPreviousRepeatedRows, tableOps.mFirstContentCellNo, previousContentRepetition,
   * tableOps.mPreviousCell, tableOps.mCurrentRange, previousContentRepetition &gt;
   * MIN_REPEATING_CONTENT_CELLS); } // if a fill sufficent repeating is now after a content, the
   * previous content was flushed if (tableOps.mFirstEqualCellNo == tableOps.mCurrentColumnNo) { //
   * but still a content and repeating content exits tableOps.mFirstContentCellNo =
   * tableOps.mFirstEqualCellNo; } else { if (currentCell != null) { tableOps.mFirstContentCellNo =
   * tableOps.mCurrentColumnNo; tableOps.mFirstEqualCellNo = tableOps.mCurrentColumnNo; } else {
   * tableOps.mFirstContentCellNo = -1; tableOps.mFirstEqualCellNo = -1; } } tableOps.mCurrentRange
   * = null; } if (!isRow) { // Making the current cell the previous for next round
   * tableOps.mPreviousCell = currentCell; tableOps.mCurrentColumnNo +=
   * tableOps.getCellRepetition(); tableOps.setCellRepetition(1); } else { // after the end of a row
   * reset all values tableOps.mSheetNo = null; tableOps.mCurrentRange = null;
   * tableOps.mPreviousCell = null; tableOps.mFirstContentCellNo = -1; tableOps.mFirstEqualCellNo =
   * -1; tableOps.mCurrentColumnNo = 0; tableOps.mEmptyCellCount = 0; tableOps.mFirstEmptyCell = -1;
   * tableOps.setCellRepetition(1); } return tableOps; }
   *
   * &lt;p&gt;static void stashColumnWidths(TableTableElement tableElement) {
   * List&lt;TableTableColumnElement&gt; existingColumnList = getTableColumnElements(tableElement, new
   * LinkedList&lt;TableTableColumnElement&gt;()); List&lt;Integer&gt; tableColumWidths =
   * OdfFileSaxHandler.collectColumnWidths(tableElement, existingColumnList);
   * tableElement.pushTableGrid(tableColumWidths); }
   *
   * &lt;p&gt;static List&lt;Integer&gt; collectColumnWidths(TableTableElement tableElement,
   * List&lt;TableTableColumnElement&gt; columns) { boolean hasRelColumnWidth = false; boolean
   * hasAbsColumnWidth = false; boolean hasColumnWithoutWidth = false; List&lt;Integer&gt; columnRelWidths
   * = new ArrayList(); for (TableTableColumnElement column : columns) { if
   * (column.hasAttributeNS(OdfDocumentNamespace.TABLE.getUri(), &quot;style-name&quot;)) { Length tableWidth
   * = getPropertyLength(StyleTablePropertiesElement.Width, tableElement);
   *
   * &lt;p&gt;int repeatedColumns = 1; if (column.hasAttributeNS(OdfDocumentNamespace.TABLE.getUri(),
   * &quot;number-columns-repeated&quot;)) { repeatedColumns =
   * Integer.parseInt(column.getAttributeNS(OdfDocumentNamespace.TABLE.getUri(),
   * &quot;number-columns-repeated&quot;)); }
   *
   * &lt;p&gt;String columnRelWidth = getProperty(StyleTableColumnPropertiesElement.RelColumnWidth,
   * column);
   *
   * &lt;p&gt;// it is being assumed, when the columnRelWidth is once set, it is always set if
   * (columnRelWidth != null &amp;&amp; !columnRelWidth.isEmpty()) { hasRelColumnWidth = true; if
   * (hasAbsColumnWidth) { LOG.warning(&quot;******* BEWARE: Absolute and relative width are not supposed
   * to be mixed!! ***********&quot;); } columnRelWidth = columnRelWidth.substring(0,
   * columnRelWidth.indexOf('*')); Integer relWidth = Integer.parseInt(columnRelWidth); for (int i =
   * 0; i &lt; repeatedColumns; i++) { columnRelWidths.add(relWidth); } } else { // if there is no
   * relative column width if (hasRelColumnWidth) { LOG.warning(&quot;******* BEWARE: Absolute and
   * relative width are not supposed to be mixed!! ***********&quot;); }
   *
   * &lt;p&gt;Length columnWidth = getPropertyLength(StyleTableColumnPropertiesElement.ColumnWidth,
   * column); // there can be only table width and .. if (tableWidth != null) { // columnwidth, with
   * a single one missing if (columnWidth != null) { hasAbsColumnWidth = true; int widthFactor =
   * (int) Math.round((columnWidth.getMillimeters() * 100) / tableWidth.getMillimeters()); for (int
   * i = 0; i &lt; repeatedColumns; i++) { columnRelWidths.add(widthFactor); } } else { if
   * (hasColumnWithoutWidth) { LOG.warning(&quot;******* BEWARE: Two columns without width and no column
   * width are not expected!! ***********&quot;); } hasColumnWithoutWidth = true; } // if the table is
   * not set, it will always be unset.. } else { if (columnWidth != null) { hasAbsColumnWidth =
   * true; int widthFactor = (int) Math.round((columnWidth.getMicrometer() * 10)); for (int i = 0; i
   * &lt; repeatedColumns; i++) { columnRelWidths.add(widthFactor); } } else { LOG.warning(&quot;*******
   * BEWARE: Two columns without width and no column width are not expected!! ***********&quot;); } } } }
   * } return columnRelWidths; } /* Returns all TableTableColumn descendants that exist within the
   * tableElement, even within groups, columns and header elements
   *
   * &lt;p&gt;static List&lt;TableTableColumnElement&gt; getTableColumnElements(Element parent, List columns) {
   * NodeList children = parent.getChildNodes(); for (int i = 0; i &lt; children.getLength(); i++) {
   * Node child = children.item(i); if (child instanceof Element) { if (child instanceof
   * TableTableColumnElement) { columns.add(child); } else if (child instanceof
   * TableTableColumnGroupElement || child instanceof TableTableHeaderColumnsElement || child
   * instanceof TableTableColumnsElement) { columns = getTableColumnElements((Element) child,
   * columns); } else if (child instanceof TableTableRowGroupElement || child instanceof
   * TableTableHeaderRowsElement || child instanceof TableTableRowElement || child instanceof
   * TableTableRowsElement) { break; } } } return columns; }
   */
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>